{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";\nimport _cloneDeep from \"lodash/cloneDeep\";\nimport { containmentMeasures } from './mitigation';\nimport { AgeGroup } from './types/Param.types';\nimport { sampleUniform } from './utils/sample';\n\nconst monthToDay = m => {\n  return m * 30 + 15;\n};\n\nconst jan2020 = new Date('2020-01-01').valueOf(); // time in ms\n\nexport function withUncertainty(scenario) {\n  const noRanges = scenario.mitigationIntervals.every(interval => interval.transmissionReduction.begin === interval.transmissionReduction.end);\n\n  if (scenario.r0.begin === scenario.r0.end && noRanges) {\n    return false;\n  }\n\n  return true;\n}\nexport const msPerDay = 1000 * 60 * 60 * 24;\n/**\n *\n * @param time - point in time, until which simulation runs, as epoch time\n * @param avgInfectionRate\n * @param peakMonth - counting number in range of 0-11\n * @param seasonalForcing -  seasonal variation in transmission. Usually a decimal number, e. g. 0.2\n * @returns\n */\n\nexport function infectionRate(time, avgInfectionRate, peakMonth, seasonalForcing) {\n  // this is super hacky\n  const phase = ((time - jan2020) / msPerDay / 365 - monthToDay(peakMonth) / 365) * 2 * Math.PI;\n  return avgInfectionRate * (1 + seasonalForcing * Math.cos(phase));\n}\nexport function getPopulationParams(scenario, severity, ageDistribution, meanOnly) {\n  const {\n    hospitalBeds,\n    hospitalStayDays,\n    icuBeds,\n    icuStayDays,\n    importsPerDay,\n    infectiousPeriodDays,\n    latencyDays,\n    mitigationIntervals,\n    numberStochasticRuns,\n    overflowSeverity,\n    peakMonth,\n    populationServed,\n    r0,\n    seasonalForcing\n  } = scenario; // TODO: Make this a form-adjustable factor\n\n  const sim = {\n    ageDistribution: [{\n      ageGroup: AgeGroup.The09,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The1019,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The2029,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The3039,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The4049,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The5059,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The6069,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The7079,\n      population: 0\n    }, {\n      ageGroup: AgeGroup.The80,\n      population: 0\n    }],\n    importsPerDay: [],\n    timeDelta: 0,\n    timeDeltaDays: 0,\n    frac: {\n      severe: [],\n      critical: [],\n      fatal: [],\n      isolated: []\n    },\n    rate: {\n      latency: 1 / latencyDays,\n      infection: () => -Infinity,\n      // Dummy infectionRate function. This is set below.\n      recovery: [],\n      severe: [],\n      discharge: [],\n      critical: [],\n      stabilize: [],\n      fatality: [],\n      overflowFatality: []\n    },\n    populationServed,\n    numberStochasticRuns,\n    hospitalBeds,\n    icuBeds\n  };\n\n  const total = _sumBy(ageDistribution, ({\n    population\n  }) => population);\n\n  severity.forEach(({\n    ageGroup,\n    confirmed,\n    critical,\n    isolated,\n    fatal,\n    severe\n  }, i) => {\n    const freq = 1.0 * ageDistribution[i].population / total;\n    sim.ageDistribution[i].population = freq;\n    sim.frac.severe[i] = severe / 100 * (confirmed / 100);\n    sim.frac.critical[i] = sim.frac.severe[i] * (critical / 100);\n    sim.frac.fatal[i] = sim.frac.critical[i] * (fatal / 100);\n    const dHospital = sim.frac.severe[i];\n    const dCritical = critical / 100;\n    const dFatal = fatal / 100; // Age specific rates\n\n    sim.frac.isolated[i] = isolated / 100;\n    sim.rate.recovery[i] = (1 - dHospital) / infectiousPeriodDays;\n    sim.rate.severe[i] = dHospital / infectiousPeriodDays;\n    sim.rate.discharge[i] = (1 - dCritical) / hospitalStayDays;\n    sim.rate.critical[i] = dCritical / hospitalStayDays;\n    sim.rate.stabilize[i] = (1 - dFatal) / icuStayDays;\n    sim.rate.fatality[i] = dFatal / icuStayDays;\n    sim.rate.overflowFatality[i] = overflowSeverity * sim.rate.fatality[i];\n  }); // Get import rates per age class (assume flat)\n\n  const L = Object.keys(sim.rate.recovery).length;\n  sim.rate.recovery.forEach((_, i) => {\n    sim.importsPerDay[i] = importsPerDay / L;\n  }); // Infectivity dynamics\n  // interpolateTimeSeries(intervalsToTimeSeries(params.mitigationIntervals))\n\n  const containmentRealization = containmentMeasures(mitigationIntervals, numberStochasticRuns, meanOnly);\n  const r0s = meanOnly ? [0.5 * (r0.begin + r0.end)] : sampleUniform(r0, numberStochasticRuns);\n  return r0s.map((tmpR0, i) => {\n    const elt = _cloneDeep(sim);\n\n    const avgInfectionRate = tmpR0 / infectiousPeriodDays;\n    const containment = containmentRealization.length > 1 ? containmentRealization[i] : containmentRealization[0];\n\n    elt.rate.infection = time => containment(time) * infectionRate(time, avgInfectionRate, peakMonth, seasonalForcing);\n\n    return elt;\n  });\n}\nexport function initializePopulation(N, numCases, t0, ageDistribution) {\n  const Z = _sumBy(ageDistribution, ({\n    population\n  }) => population);\n\n  const pop = {\n    time: t0,\n    current: {\n      susceptible: [],\n      exposed: [],\n      infectious: [],\n      severe: [],\n      critical: [],\n      overflow: []\n    },\n    cumulative: {\n      recovered: [],\n      hospitalized: [],\n      critical: [],\n      fatality: []\n    }\n  }; // specification of the initial condition: there are numCases at tMin\n  // of those, 0.3 are infectious, the remainder is exposed and will turn\n  // infectious as they propagate through the exposed categories.\n\n  const initialInfectiousFraction = 0.3;\n  ageDistribution.forEach(({\n    population\n  }, i) => {\n    const n = Math.round(population / Z * N);\n    pop.current.susceptible[i] = n;\n    pop.current.exposed[i] = [0, 0, 0];\n    pop.current.infectious[i] = 0;\n    pop.current.severe[i] = 0;\n    pop.current.critical[i] = 0;\n    pop.current.overflow[i] = 0;\n    pop.cumulative.hospitalized[i] = 0;\n    pop.cumulative.recovered[i] = 0;\n    pop.cumulative.critical[i] = 0;\n    pop.cumulative.fatality[i] = 0;\n\n    if (i === Math.round(ageDistribution.length / 2)) {\n      pop.current.susceptible[i] -= numCases;\n      pop.current.infectious[i] = initialInfectiousFraction * numCases;\n      const e = (1 - initialInfectiousFraction) * numCases / pop.current.exposed[i].length;\n      pop.current.exposed[i] = pop.current.exposed[i].map(_ => e);\n    }\n  });\n  return pop;\n}","map":{"version":3,"sources":["/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/src/algorithms/initialize.ts"],"names":["containmentMeasures","AgeGroup","sampleUniform","monthToDay","m","jan2020","Date","valueOf","withUncertainty","scenario","noRanges","mitigationIntervals","every","interval","transmissionReduction","begin","end","r0","msPerDay","infectionRate","time","avgInfectionRate","peakMonth","seasonalForcing","phase","Math","PI","cos","getPopulationParams","severity","ageDistribution","meanOnly","hospitalBeds","hospitalStayDays","icuBeds","icuStayDays","importsPerDay","infectiousPeriodDays","latencyDays","numberStochasticRuns","overflowSeverity","populationServed","sim","ageGroup","The09","population","The1019","The2029","The3039","The4049","The5059","The6069","The7079","The80","timeDelta","timeDeltaDays","frac","severe","critical","fatal","isolated","rate","latency","infection","Infinity","recovery","discharge","stabilize","fatality","overflowFatality","total","forEach","confirmed","i","freq","dHospital","dCritical","dFatal","L","Object","keys","length","_","containmentRealization","r0s","map","tmpR0","elt","containment","initializePopulation","N","numCases","t0","Z","pop","current","susceptible","exposed","infectious","overflow","cumulative","recovered","hospitalized","initialInfectiousFraction","n","round","e"],"mappings":"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","sourcesContent":["import { cloneDeep, sumBy } from 'lodash'\nimport { containmentMeasures } from './mitigation'\nimport { AgeDistributionDatum, AgeGroup, ScenarioFlat, SeverityDistributionDatum } from './types/Param.types'\nimport { ModelParams, SimulationTimePoint } from './types/Result.types'\n\nimport { sampleUniform } from './utils/sample'\n\nconst monthToDay = (m: number) => {\n  return m * 30 + 15\n}\n\nconst jan2020 = new Date('2020-01-01').valueOf() // time in ms\n\nexport function withUncertainty(scenario: ScenarioFlat): boolean {\n  const noRanges = scenario.mitigationIntervals.every(\n    (interval) => interval.transmissionReduction.begin === interval.transmissionReduction.end,\n  )\n  if (scenario.r0.begin === scenario.r0.end && noRanges) {\n    return false\n  }\n  return true\n}\n\nexport const msPerDay = 1000 * 60 * 60 * 24\n\n/**\n *\n * @param time - point in time, until which simulation runs, as epoch time\n * @param avgInfectionRate\n * @param peakMonth - counting number in range of 0-11\n * @param seasonalForcing -  seasonal variation in transmission. Usually a decimal number, e. g. 0.2\n * @returns\n */\nexport function infectionRate(\n  time: number,\n  avgInfectionRate: number,\n  peakMonth: number,\n  seasonalForcing: number,\n): number {\n  // this is super hacky\n  const phase = ((time - jan2020) / msPerDay / 365 - monthToDay(peakMonth) / 365) * 2 * Math.PI\n  return avgInfectionRate * (1 + seasonalForcing * Math.cos(phase))\n}\n\nexport function getPopulationParams(\n  scenario: ScenarioFlat,\n  severity: SeverityDistributionDatum[],\n  ageDistribution: AgeDistributionDatum[],\n  meanOnly: boolean,\n): ModelParams[] {\n  const {\n    hospitalBeds,\n    hospitalStayDays,\n    icuBeds,\n    icuStayDays,\n    importsPerDay,\n    infectiousPeriodDays,\n    latencyDays,\n    mitigationIntervals,\n    numberStochasticRuns,\n    overflowSeverity,\n    peakMonth,\n    populationServed,\n    r0,\n    seasonalForcing,\n  } = scenario\n\n  // TODO: Make this a form-adjustable factor\n  const sim: ModelParams = {\n    ageDistribution: [\n      { ageGroup: AgeGroup.The09, population: 0 },\n      { ageGroup: AgeGroup.The1019, population: 0 },\n      { ageGroup: AgeGroup.The2029, population: 0 },\n      { ageGroup: AgeGroup.The3039, population: 0 },\n      { ageGroup: AgeGroup.The4049, population: 0 },\n      { ageGroup: AgeGroup.The5059, population: 0 },\n      { ageGroup: AgeGroup.The6069, population: 0 },\n      { ageGroup: AgeGroup.The7079, population: 0 },\n      { ageGroup: AgeGroup.The80, population: 0 },\n    ],\n    importsPerDay: [],\n    timeDelta: 0,\n    timeDeltaDays: 0,\n    frac: {\n      severe: [],\n      critical: [],\n      fatal: [],\n      isolated: [],\n    },\n    rate: {\n      latency: 1 / latencyDays,\n      infection: () => -Infinity, // Dummy infectionRate function. This is set below.\n      recovery: [],\n      severe: [],\n      discharge: [],\n      critical: [],\n      stabilize: [],\n      fatality: [],\n      overflowFatality: [],\n    },\n\n    populationServed,\n    numberStochasticRuns,\n    hospitalBeds,\n    icuBeds,\n  }\n\n  const total = sumBy(ageDistribution, ({ population }) => population)\n\n  severity.forEach(({ ageGroup, confirmed, critical, isolated, fatal, severe }, i) => {\n    const freq = (1.0 * ageDistribution[i].population) / total\n    sim.ageDistribution[i].population = freq\n    sim.frac.severe[i] = (severe / 100) * (confirmed / 100)\n    sim.frac.critical[i] = sim.frac.severe[i] * (critical / 100)\n    sim.frac.fatal[i] = sim.frac.critical[i] * (fatal / 100)\n\n    const dHospital = sim.frac.severe[i]\n    const dCritical = critical / 100\n    const dFatal = fatal / 100\n\n    // Age specific rates\n    sim.frac.isolated[i] = isolated / 100\n    sim.rate.recovery[i] = (1 - dHospital) / infectiousPeriodDays\n    sim.rate.severe[i] = dHospital / infectiousPeriodDays\n    sim.rate.discharge[i] = (1 - dCritical) / hospitalStayDays\n    sim.rate.critical[i] = dCritical / hospitalStayDays\n    sim.rate.stabilize[i] = (1 - dFatal) / icuStayDays\n    sim.rate.fatality[i] = dFatal / icuStayDays\n    sim.rate.overflowFatality[i] = overflowSeverity * sim.rate.fatality[i]\n  })\n\n  // Get import rates per age class (assume flat)\n  const L = Object.keys(sim.rate.recovery).length\n  sim.rate.recovery.forEach((_, i) => {\n    sim.importsPerDay[i] = importsPerDay / L\n  })\n\n  // Infectivity dynamics\n  // interpolateTimeSeries(intervalsToTimeSeries(params.mitigationIntervals))\n  const containmentRealization = containmentMeasures(mitigationIntervals, numberStochasticRuns, meanOnly)\n\n  const r0s = meanOnly ? [0.5 * (r0.begin + r0.end)] : sampleUniform(r0, numberStochasticRuns)\n  return r0s.map((tmpR0, i) => {\n    const elt = cloneDeep(sim)\n    const avgInfectionRate = tmpR0 / infectiousPeriodDays\n\n    const containment = containmentRealization.length > 1 ? containmentRealization[i] : containmentRealization[0]\n    elt.rate.infection = (time: number) =>\n      containment(time) * infectionRate(time, avgInfectionRate, peakMonth, seasonalForcing)\n\n    return elt\n  })\n}\n\nexport function initializePopulation(\n  N: number,\n  numCases: number,\n  t0: number,\n  ageDistribution: AgeDistributionDatum[],\n): SimulationTimePoint {\n  const Z = sumBy(ageDistribution, ({ population }) => population)\n  const pop: SimulationTimePoint = {\n    time: t0,\n    current: {\n      susceptible: [],\n      exposed: [],\n      infectious: [],\n      severe: [],\n      critical: [],\n      overflow: [],\n    },\n    cumulative: {\n      recovered: [],\n      hospitalized: [],\n      critical: [],\n      fatality: [],\n    },\n  }\n\n  // specification of the initial condition: there are numCases at tMin\n  // of those, 0.3 are infectious, the remainder is exposed and will turn\n  // infectious as they propagate through the exposed categories.\n  const initialInfectiousFraction = 0.3\n\n  ageDistribution.forEach(({ population }, i) => {\n    const n = Math.round((population / Z) * N)\n    pop.current.susceptible[i] = n\n    pop.current.exposed[i] = [0, 0, 0]\n    pop.current.infectious[i] = 0\n    pop.current.severe[i] = 0\n    pop.current.critical[i] = 0\n    pop.current.overflow[i] = 0\n    pop.cumulative.hospitalized[i] = 0\n    pop.cumulative.recovered[i] = 0\n    pop.cumulative.critical[i] = 0\n    pop.cumulative.fatality[i] = 0\n\n    if (i === Math.round(ageDistribution.length / 2)) {\n      pop.current.susceptible[i] -= numCases\n      pop.current.infectious[i] = initialInfectiousFraction * numCases\n      const e = ((1 - initialInfectiousFraction) * numCases) / pop.current.exposed[i].length\n      pop.current.exposed[i] = pop.current.exposed[i].map((_) => e)\n    }\n  })\n\n  return pop\n}\n"]},"metadata":{},"sourceType":"module"}