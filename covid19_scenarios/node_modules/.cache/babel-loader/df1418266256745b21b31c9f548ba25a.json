{"ast":null,"code":"import _clamp from \"lodash/clamp\";\nimport { sampleRandom } from './utils/sample'; // -----------------------------------------------------------------------\n// Utility functions\n\nfunction trypush(arr, val) {\n  if (arr !== undefined) {\n    arr.push(val);\n    return arr;\n  }\n\n  return [val];\n} // -----------------------------------------------------------------------\n// Internal functions\n\n\nfunction strength(mitigation) {\n  return _clamp(1 - mitigation / 100, 0.01, 1);\n}\n\nfunction sampleMitigationRealizations(intervals, numberStochasticRuns, meanOnly) {\n  const noRanges = intervals.every(interval => interval.transmissionReduction.begin === interval.transmissionReduction.end);\n\n  if (noRanges || meanOnly) {\n    return [intervals.map(interval => ({\n      val: strength(0.5 * (interval.transmissionReduction.begin + interval.transmissionReduction.end)),\n      tMin: interval.timeRange.begin.valueOf(),\n      tMax: interval.timeRange.end.valueOf()\n    }))];\n  }\n\n  return Array(numberStochasticRuns).fill(1).map(() => intervals.map(interval => ({\n    val: strength(sampleRandom(interval.transmissionReduction)),\n    tMin: interval.timeRange.begin.valueOf(),\n    tMax: interval.timeRange.end.valueOf()\n  })));\n}\n\nfunction timeSeriesOf(measures) {\n  const changePoints = {};\n  measures.forEach(measure => {\n    const {\n      val,\n      tMin,\n      tMax\n    } = measure;\n    changePoints[tMin] = trypush(changePoints[tMin], val);\n    changePoints[tMax] = trypush(changePoints[tMax], 1.0 / val);\n  });\n  const orderedChangePoints = Object.entries(changePoints).map(([t, vals]) => ({\n    t: Number(t),\n    val: vals\n  })).sort((a, b) => a.t - b.t);\n\n  if (orderedChangePoints.length > 0) {\n    const mitigation = [{\n      t: orderedChangePoints[0].t,\n      y: 1.0\n    }];\n    orderedChangePoints.forEach((d, i) => {\n      const oldValue = mitigation[2 * i].y;\n      const newValue = d.val.reduce((a, b) => a * b, oldValue);\n      mitigation.push({\n        t: d.t,\n        y: oldValue\n      });\n      mitigation.push({\n        t: d.t,\n        y: newValue\n      });\n    });\n    return mitigation;\n  }\n\n  return [];\n} // NOTE: Assumes containment is sorted ascending in time.\n\n\nfunction interpolateTimeSeries(containment) {\n  if (containment.length === 0) {\n    return () => 1.0;\n  }\n\n  const Ys = containment.map(d => d.y);\n  const Ts = containment.map(d => d.t);\n  return t => {\n    if (t <= containment[0].t) {\n      return containment[0].y;\n    }\n\n    if (t >= containment[containment.length - 1].t) {\n      return containment[containment.length - 1].y;\n    }\n\n    const i = containment.findIndex(d => t < d.t);\n\n    const evalLinear = t => {\n      const deltaY = Ys[i] - Ys[i - 1];\n      const deltaT = Ts[i] - Ts[i - 1];\n      const dS = deltaY / deltaT;\n      const dT = t - Ts[i - 1];\n      return Ys[i - 1] + dS * dT;\n    };\n\n    return evalLinear(t);\n  };\n} // -----------------------------------------------------------------------\n// Exported functions\n\n\nexport function containmentMeasures(intervals, numberStochasticRuns, meanOnly) {\n  return sampleMitigationRealizations(intervals, numberStochasticRuns, meanOnly).map(sample => interpolateTimeSeries(timeSeriesOf(sample)));\n}","map":{"version":3,"sources":["/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/src/algorithms/mitigation.ts"],"names":["sampleRandom","trypush","arr","val","undefined","push","strength","mitigation","sampleMitigationRealizations","intervals","numberStochasticRuns","meanOnly","noRanges","every","interval","transmissionReduction","begin","end","map","tMin","timeRange","valueOf","tMax","Array","fill","timeSeriesOf","measures","changePoints","forEach","measure","orderedChangePoints","Object","entries","t","vals","Number","sort","a","b","length","y","d","i","oldValue","newValue","reduce","interpolateTimeSeries","containment","Ys","Ts","findIndex","evalLinear","deltaY","deltaT","dS","dT","containmentMeasures","sample"],"mappings":"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","sourcesContent":["import { clamp } from 'lodash'\nimport { TimeSeries } from './types/TimeSeries.types'\nimport { MitigationInterval } from './types/Param.types'\nimport { sampleRandom } from './utils/sample'\n\n// -----------------------------------------------------------------------\n// Utility functions\n\nfunction trypush(arr: undefined | number[], val: number): number[] {\n  if (arr !== undefined) {\n    arr.push(val)\n    return arr\n  }\n  return [val]\n}\n\n// -----------------------------------------------------------------------\n// Internal functions\n\ninterface MitigationMeasure {\n  val: number\n  tMin: number\n  tMax: number\n}\n\nfunction strength(mitigation: number): number {\n  return clamp(1 - mitigation / 100, 0.01, 1)\n}\n\nfunction sampleMitigationRealizations(\n  intervals: MitigationInterval[],\n  numberStochasticRuns: number,\n  meanOnly: boolean,\n): MitigationMeasure[][] {\n  const noRanges = intervals.every(\n    (interval) => interval.transmissionReduction.begin === interval.transmissionReduction.end,\n  )\n\n  if (noRanges || meanOnly) {\n    return [\n      intervals.map((interval) => ({\n        val: strength(0.5 * (interval.transmissionReduction.begin + interval.transmissionReduction.end)),\n        tMin: interval.timeRange.begin.valueOf(),\n        tMax: interval.timeRange.end.valueOf(),\n      })),\n    ]\n  }\n\n  return Array(numberStochasticRuns)\n    .fill(1)\n    .map(() =>\n      intervals.map((interval) => ({\n        val: strength(sampleRandom(interval.transmissionReduction)),\n        tMin: interval.timeRange.begin.valueOf(),\n        tMax: interval.timeRange.end.valueOf(),\n      })),\n    )\n}\n\nfunction timeSeriesOf(measures: MitigationMeasure[]): TimeSeries {\n  const changePoints: Record<number, number[]> = {}\n  measures.forEach((measure) => {\n    const { val, tMin, tMax } = measure\n    changePoints[tMin] = trypush(changePoints[tMin], val)\n    changePoints[tMax] = trypush(changePoints[tMax], 1.0 / val)\n  })\n\n  const orderedChangePoints = Object.entries(changePoints)\n    .map(([t, vals]) => ({\n      t: Number(t),\n      val: vals,\n    }))\n    .sort((a, b): number => a.t - b.t)\n\n  if (orderedChangePoints.length > 0) {\n    const mitigation: TimeSeries = [{ t: orderedChangePoints[0].t, y: 1.0 }]\n\n    orderedChangePoints.forEach((d, i) => {\n      const oldValue = mitigation[2 * i].y\n      const newValue = d.val.reduce((a, b) => a * b, oldValue)\n\n      mitigation.push({ t: d.t, y: oldValue })\n      mitigation.push({ t: d.t, y: newValue })\n    })\n\n    return mitigation\n  }\n\n  return []\n}\n\n// NOTE: Assumes containment is sorted ascending in time.\ntype Func = (t: number) => number\nfunction interpolateTimeSeries(containment: TimeSeries): Func {\n  if (containment.length === 0) {\n    return () => 1.0\n  }\n\n  const Ys = containment.map((d) => d.y)\n  const Ts = containment.map((d) => d.t)\n  return (t: number) => {\n    if (t <= containment[0].t) {\n      return containment[0].y\n    }\n    if (t >= containment[containment.length - 1].t) {\n      return containment[containment.length - 1].y\n    }\n    const i = containment.findIndex((d) => t < d.t)\n\n    const evalLinear = (t: number) => {\n      const deltaY = Ys[i] - Ys[i - 1]\n      const deltaT = Ts[i] - Ts[i - 1]\n\n      const dS = deltaY / deltaT\n      const dT = t - Ts[i - 1]\n\n      return Ys[i - 1] + dS * dT\n    }\n\n    return evalLinear(t)\n  }\n}\n\n// -----------------------------------------------------------------------\n// Exported functions\n\nexport function containmentMeasures(\n  intervals: MitigationInterval[],\n  numberStochasticRuns: number,\n  meanOnly: boolean,\n): Func[] {\n  return sampleMitigationRealizations(intervals, numberStochasticRuns, meanOnly).map((sample) =>\n    interpolateTimeSeries(timeSeriesOf(sample)),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}