{"ast":null,"code":"// -----------------------------------------------------------------------\n// Simulation data methods\n\n/* Constructors */\nfunction emptyTimePoint(t) {\n  return {\n    time: t,\n    // Dummy\n    current: {\n      susceptible: {},\n      severe: {},\n      critical: {},\n      exposed: {},\n      infectious: {},\n      overflow: {},\n      weeklyFatality: {}\n    },\n    cumulative: {\n      recovered: {},\n      critical: {},\n      hospitalized: {},\n      fatality: {}\n    }\n  };\n}\n\nexport function emptyTrajectory(len) {\n  const arr = [];\n\n  while (arr.length < len) {\n    arr.push(emptyTimePoint(Date.now()));\n  }\n\n  return arr;\n}\n/* Binary operations */\n\nfunction operationTP(x, y, operator) {\n  return {\n    time: y.time,\n    current: {\n      susceptible: operator(x.current.susceptible, y.current.susceptible),\n      severe: operator(x.current.severe, y.current.severe),\n      exposed: operator(x.current.exposed, y.current.exposed),\n      critical: operator(x.current.critical, y.current.critical),\n      overflow: operator(x.current.overflow, y.current.overflow),\n      infectious: operator(x.current.infectious, y.current.infectious),\n      weeklyFatality: operator(x.current.weeklyFatality, y.current.weeklyFatality)\n    },\n    cumulative: {\n      critical: operator(x.cumulative.critical, y.cumulative.critical),\n      fatality: operator(x.cumulative.fatality, y.cumulative.fatality),\n      recovered: operator(x.cumulative.recovered, y.cumulative.recovered),\n      hospitalized: operator(x.cumulative.hospitalized, y.cumulative.hospitalized)\n    }\n  };\n}\n\nexport function addTP(x, y) {\n  return operationTP(x, y, (dict, other) => {\n    const s = {};\n    Object.keys(other).forEach(k => {\n      if (!(k in dict)) {\n        s[k] = other[k];\n      } else {\n        s[k] = dict[k] + other[k];\n      }\n    });\n    return s;\n  });\n}\nexport function subTP(x, y) {\n  return operationTP(x, y, (dict, other) => {\n    const s = {};\n    Object.keys(other).forEach(k => {\n      if (!(k in dict)) {\n        s[k] = other[k];\n      } else {\n        s[k] = dict[k] - other[k];\n      }\n    });\n    return s;\n  });\n}\nexport function mulTP(x, y) {\n  return operationTP(x, y, (dict, other) => {\n    const s = {};\n    Object.keys(dict).forEach(k => {\n      s[k] = dict[k] * other[k];\n    });\n    return s;\n  });\n}\nexport function divTP(x, y) {\n  return operationTP(x, y, (dict, other) => {\n    const s = {};\n    Object.keys(dict).forEach(k => {\n      s[k] = dict[k] / other[k];\n    });\n    return s;\n  });\n}\n/* Unary operations */\n\nfunction scaleTP(x, transform) {\n  const scale = dict => {\n    const s = {};\n    Object.keys(dict).forEach(k => {\n      s[k] = transform(dict[k]);\n    });\n    return s;\n  };\n\n  return {\n    time: x.time,\n    current: {\n      susceptible: scale(x.current.susceptible),\n      severe: scale(x.current.severe),\n      exposed: scale(x.current.exposed),\n      critical: scale(x.current.critical),\n      overflow: scale(x.current.overflow),\n      infectious: scale(x.current.infectious)\n    },\n    cumulative: {\n      critical: scale(x.cumulative.critical),\n      fatality: scale(x.cumulative.fatality),\n      recovered: scale(x.cumulative.recovered),\n      hospitalized: scale(x.cumulative.hospitalized)\n    }\n  };\n}\n/* N-ary operations (TP -> TPs) */\n\n\nfunction scaledMeanTPs(tps, fwd, inv) {\n  const N = tps.length;\n  let mean = emptyTimePoint(tps[0].time);\n  tps.forEach(tp => {\n    mean = addTP(mean, scaleTP(tp, fwd));\n  });\n  mean = scaleTP(mean, x => inv(x / N));\n  return mean;\n}\n\nfunction scaledStdDevTPs(tps, mean, fwd, inv) {\n  const N = tps.length;\n  const M = scaleTP(mean, x => -fwd(x));\n  let logvar = emptyTimePoint(tps[0].time);\n  tps.forEach(tp => {\n    logvar = addTP(logvar, scaleTP(addTP(scaleTP(tp, x => fwd(x + COUNT_FLOOR)), M), x => x * x));\n  });\n  const logstd = scaleTP(logvar, x => Math.pow(x / N, 1 / 2));\n  return scaleTP(logstd, inv);\n}\n\nexport function percentileTPs(tps, prc) {\n  const res = emptyTimePoint(tps[0].time);\n  const idx = Math.ceil(prc * (tps.length - 1));\n  Object.keys(tps[0]).forEach(kind => {\n    Object.keys(tps[0][kind]).forEach(k => {\n      Object.keys(tps[0][kind][k]).forEach(age => {\n        res[kind][k][age] = tps.map(d => d[kind][k][age]).sort((x, y) => x - y)[idx];\n      });\n    });\n  });\n  return res;\n} // -----------------------------------------------------------------------\n// Operations on sets of realizations\n\nexport function percentileTrajectory(trajectories, prc) {\n  return trajectories[0].map((_0, i) => {\n    return percentileTPs(trajectories.map(traj => traj[i]), prc);\n  });\n}\nconst COUNT_FLOOR = 1e-1;\n\nconst fwdTransform = x => Math.log(x + COUNT_FLOOR);\n\nconst invTransform = x => Math.exp(x);\n\nexport function meanTrajectory(trajectories) {\n  return trajectories[0].map((_0, i) => {\n    return scaledMeanTPs(trajectories.map((_1, j) => trajectories[j][i]), fwdTransform, invTransform);\n  });\n}\nexport function stddevTrajectory(trajectories, mean) {\n  return trajectories[0].map((_0, i) => {\n    return scaledStdDevTPs(trajectories.map((_1, j) => trajectories[j][i]), mean[i], fwdTransform, invTransform);\n  });\n}","map":{"version":3,"sources":["/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/src/algorithms/results.ts"],"names":["emptyTimePoint","t","time","current","susceptible","severe","critical","exposed","infectious","overflow","weeklyFatality","cumulative","recovered","hospitalized","fatality","emptyTrajectory","len","arr","length","push","Date","now","operationTP","x","y","operator","addTP","dict","other","s","Object","keys","forEach","k","subTP","mulTP","divTP","scaleTP","transform","scale","scaledMeanTPs","tps","fwd","inv","N","mean","tp","scaledStdDevTPs","M","logvar","COUNT_FLOOR","logstd","Math","pow","percentileTPs","prc","res","idx","ceil","kind","age","map","d","sort","percentileTrajectory","trajectories","_0","i","traj","fwdTransform","log","invTransform","exp","meanTrajectory","_1","j","stddevTrajectory"],"mappings":"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","sourcesContent":["import { ExportedTimePoint } from './types/Result.types'\n\n// -----------------------------------------------------------------------\n// Simulation data methods\n\n/* Constructors */\nfunction emptyTimePoint(t: number): ExportedTimePoint {\n  return {\n    time: t, // Dummy\n    current: {\n      susceptible: {},\n      severe: {},\n      critical: {},\n      exposed: {},\n      infectious: {},\n      overflow: {},\n      weeklyFatality: {},\n    },\n    cumulative: {\n      recovered: {},\n      critical: {},\n      hospitalized: {},\n      fatality: {},\n    },\n  }\n}\n\nexport function emptyTrajectory(len: number): ExportedTimePoint[] {\n  const arr: ExportedTimePoint[] = []\n  while (arr.length < len) {\n    arr.push(emptyTimePoint(Date.now()))\n  }\n\n  return arr\n}\n\n/* Binary operations */\nfunction operationTP(\n  x: ExportedTimePoint,\n  y: ExportedTimePoint,\n  operator: (dict: Record<string, number>, other: Record<string, number>) => Record<string, number>,\n) {\n  return {\n    time: y.time,\n    current: {\n      susceptible: operator(x.current.susceptible, y.current.susceptible),\n      severe: operator(x.current.severe, y.current.severe),\n      exposed: operator(x.current.exposed, y.current.exposed),\n      critical: operator(x.current.critical, y.current.critical),\n      overflow: operator(x.current.overflow, y.current.overflow),\n      infectious: operator(x.current.infectious, y.current.infectious),\n      weeklyFatality: operator(x.current.weeklyFatality, y.current.weeklyFatality),\n    },\n    cumulative: {\n      critical: operator(x.cumulative.critical, y.cumulative.critical),\n      fatality: operator(x.cumulative.fatality, y.cumulative.fatality),\n      recovered: operator(x.cumulative.recovered, y.cumulative.recovered),\n      hospitalized: operator(x.cumulative.hospitalized, y.cumulative.hospitalized),\n    },\n  }\n}\n\nexport function addTP(x: ExportedTimePoint, y: ExportedTimePoint): ExportedTimePoint {\n  return operationTP(\n    x,\n    y,\n    (dict: Record<string, number>, other: Record<string, number>): Record<string, number> => {\n      const s: Record<string, number> = {}\n      Object.keys(other).forEach((k) => {\n        if (!(k in dict)) {\n          s[k] = other[k]\n        } else {\n          s[k] = dict[k] + other[k]\n        }\n      })\n\n      return s\n    },\n  )\n}\n\nexport function subTP(x: ExportedTimePoint, y: ExportedTimePoint): ExportedTimePoint {\n  return operationTP(\n    x,\n    y,\n    (dict: Record<string, number>, other: Record<string, number>): Record<string, number> => {\n      const s: Record<string, number> = {}\n      Object.keys(other).forEach((k) => {\n        if (!(k in dict)) {\n          s[k] = other[k]\n        } else {\n          s[k] = dict[k] - other[k]\n        }\n      })\n\n      return s\n    },\n  )\n}\n\nexport function mulTP(x: ExportedTimePoint, y: ExportedTimePoint): ExportedTimePoint {\n  return operationTP(\n    x,\n    y,\n    (dict: Record<string, number>, other: Record<string, number>): Record<string, number> => {\n      const s: Record<string, number> = {}\n      Object.keys(dict).forEach((k) => {\n        s[k] = dict[k] * other[k]\n      })\n\n      return s\n    },\n  )\n}\n\nexport function divTP(x: ExportedTimePoint, y: ExportedTimePoint): ExportedTimePoint {\n  return operationTP(\n    x,\n    y,\n    (dict: Record<string, number>, other: Record<string, number>): Record<string, number> => {\n      const s: Record<string, number> = {}\n      Object.keys(dict).forEach((k) => {\n        s[k] = dict[k] / other[k]\n      })\n\n      return s\n    },\n  )\n}\n\n/* Unary operations */\nfunction scaleTP(x: ExportedTimePoint, transform: (x: number) => number): ExportedTimePoint {\n  const scale = (dict: Record<string, number>): Record<string, number> => {\n    const s: Record<string, number> = {}\n    Object.keys(dict).forEach((k) => {\n      s[k] = transform(dict[k])\n    })\n\n    return s\n  }\n  return {\n    time: x.time,\n    current: {\n      susceptible: scale(x.current.susceptible),\n      severe: scale(x.current.severe),\n      exposed: scale(x.current.exposed),\n      critical: scale(x.current.critical),\n      overflow: scale(x.current.overflow),\n      infectious: scale(x.current.infectious),\n    },\n    cumulative: {\n      critical: scale(x.cumulative.critical),\n      fatality: scale(x.cumulative.fatality),\n      recovered: scale(x.cumulative.recovered),\n      hospitalized: scale(x.cumulative.hospitalized),\n    },\n  }\n}\n\n/* N-ary operations (TP -> TPs) */\nfunction scaledMeanTPs(\n  tps: ExportedTimePoint[],\n  fwd: (x: number) => number,\n  inv: (x: number) => number,\n): ExportedTimePoint {\n  const N = tps.length\n\n  let mean: ExportedTimePoint = emptyTimePoint(tps[0].time)\n  tps.forEach((tp) => {\n    mean = addTP(mean, scaleTP(tp, fwd))\n  })\n  mean = scaleTP(mean, (x) => inv(x / N))\n\n  return mean\n}\n\nfunction scaledStdDevTPs(\n  tps: ExportedTimePoint[],\n  mean: ExportedTimePoint,\n  fwd: (x: number) => number,\n  inv: (x: number) => number,\n): ExportedTimePoint {\n  const N = tps.length\n  const M = scaleTP(mean, (x) => -fwd(x))\n\n  let logvar: ExportedTimePoint = emptyTimePoint(tps[0].time)\n  tps.forEach((tp) => {\n    logvar = addTP(\n      logvar,\n      scaleTP(\n        addTP(\n          scaleTP(tp, (x) => fwd(x + COUNT_FLOOR)),\n          M,\n        ),\n        (x) => x * x,\n      ),\n    )\n  })\n\n  const logstd = scaleTP(logvar, (x) => Math.pow(x / N, 1 / 2))\n\n  return scaleTP(logstd, inv)\n}\n\nexport function percentileTPs(tps: ExportedTimePoint[], prc: number): ExportedTimePoint {\n  const res: ExportedTimePoint = emptyTimePoint(tps[0].time)\n  const idx = Math.ceil(prc * (tps.length - 1))\n\n  Object.keys(tps[0]).forEach((kind) => {\n    Object.keys(tps[0][kind]).forEach((k) => {\n      Object.keys(tps[0][kind][k]).forEach((age) => {\n        res[kind][k][age] = tps.map((d) => d[kind][k][age]).sort((x, y) => x - y)[idx]\n      })\n    })\n  })\n\n  return res\n}\n\n// -----------------------------------------------------------------------\n// Operations on sets of realizations\n\nexport function percentileTrajectory(trajectories: ExportedTimePoint[][], prc: number): ExportedTimePoint[] {\n  return trajectories[0].map((_0, i) => {\n    return percentileTPs(\n      trajectories.map((traj) => traj[i]),\n      prc,\n    )\n  })\n}\n\nconst COUNT_FLOOR = 1e-1\nconst fwdTransform = (x: number) => Math.log(x + COUNT_FLOOR)\nconst invTransform = (x: number) => Math.exp(x)\n\nexport function meanTrajectory(trajectories: ExportedTimePoint[][]): ExportedTimePoint[] {\n  return trajectories[0].map((_0, i) => {\n    return scaledMeanTPs(\n      trajectories.map((_1, j) => trajectories[j][i]),\n      fwdTransform,\n      invTransform,\n    )\n  })\n}\n\nexport function stddevTrajectory(trajectories: ExportedTimePoint[][], mean: ExportedTimePoint[]): ExportedTimePoint[] {\n  return trajectories[0].map((_0, i) => {\n    return scaledStdDevTPs(\n      trajectories.map((_1, j) => trajectories[j][i]),\n      mean[i],\n      fwdTransform,\n      invTransform,\n    )\n  })\n}\n"]},"metadata":{},"sourceType":"module"}