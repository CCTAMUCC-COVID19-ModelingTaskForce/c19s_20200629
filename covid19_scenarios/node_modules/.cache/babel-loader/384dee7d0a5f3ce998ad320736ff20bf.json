{"ast":null,"code":"import { getPopulationParams, initializePopulation, withUncertainty } from './initialize';\nimport { collectTotals, evolve } from './model';\nimport { percentileTrajectory } from './results';\nimport { preparePlotData } from './preparePlotData';\n\nconst identity = x => x;\n\nfunction simulate(initialState, params, tMax, ageGroups, func) {\n  const dynamics = [initialState];\n  let currState = initialState;\n\n  while (currState.time < tMax) {\n    currState = evolve(currState, params, currState.time + 1, func);\n    dynamics.push(currState);\n  }\n\n  return collectTotals(dynamics, ageGroups);\n}\n\nexport async function run({\n  params,\n  severity,\n  ageDistribution\n}) {\n  const tMin = new Date(params.simulationTimeRange.begin).getTime();\n  const tMax = new Date(params.simulationTimeRange.end).getTime();\n  const ageGroups = ageDistribution.map(d => d.ageGroup);\n  const initialCases = params.initialNumberOfCases;\n  const stochastic = withUncertainty(params);\n  let stochasticTrajectories = [];\n  let stochasticParams = [];\n\n  if (stochastic) {\n    stochasticParams = getPopulationParams(params, severity, ageDistribution, false);\n    stochasticTrajectories = stochasticParams.map(modelParams => {\n      const tmpPopulation = initializePopulation(modelParams.populationServed, initialCases, tMin, ageDistribution);\n      return simulate(tmpPopulation, modelParams, tMax, ageGroups, identity);\n    });\n  }\n\n  const deterministicParams = getPopulationParams(params, severity, ageDistribution, true)[0];\n  const population = initializePopulation(deterministicParams.populationServed, initialCases, tMin, ageDistribution);\n  const deterministicTrajectory = simulate(population, deterministicParams, tMax, ageGroups, identity);\n  const thresholds = [0.2, 0.8];\n  const idxs = thresholds.map(d => Math.ceil((stochasticTrajectories.length - 1) * d));\n  const R0Trajectories = stochastic ? deterministicTrajectory.map(d => {\n    return {\n      t: d.time,\n      y: stochasticParams.map(ModelParams => ModelParams.rate.infection(d.time) * params.infectiousPeriodDays).sort((a, b) => a - b)\n    };\n  }) : [];\n  const meanR0Trajectory = deterministicTrajectory.map(d => {\n    return {\n      t: d.time,\n      y: deterministicParams.rate.infection(d.time) * params.infectiousPeriodDays\n    };\n  });\n  const resultsTrajectory = {\n    lower: stochastic ? percentileTrajectory(stochasticTrajectories, 0.2) : deterministicTrajectory,\n    middle: deterministicTrajectory,\n    upper: stochastic ? percentileTrajectory(stochasticTrajectories, 0.8) : deterministicTrajectory,\n    percentile: {}\n  };\n  return {\n    trajectory: resultsTrajectory,\n    R0: {\n      mean: meanR0Trajectory,\n      lower: stochastic ? R0Trajectories.map(d => ({\n        t: d.t,\n        y: d.y[idxs[0]]\n      })) : meanR0Trajectory,\n      upper: stochastic ? R0Trajectories.map(d => ({\n        t: d.t,\n        y: d.y[idxs[1]]\n      })) : meanR0Trajectory\n    },\n    plotData: preparePlotData(resultsTrajectory)\n  };\n}","map":{"version":3,"sources":["/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/src/algorithms/run.ts"],"names":["getPopulationParams","initializePopulation","withUncertainty","collectTotals","evolve","percentileTrajectory","preparePlotData","identity","x","simulate","initialState","params","tMax","ageGroups","func","dynamics","currState","time","push","run","severity","ageDistribution","tMin","Date","simulationTimeRange","begin","getTime","end","map","d","ageGroup","initialCases","initialNumberOfCases","stochastic","stochasticTrajectories","stochasticParams","modelParams","tmpPopulation","populationServed","deterministicParams","population","deterministicTrajectory","thresholds","idxs","Math","ceil","length","R0Trajectories","t","y","ModelParams","rate","infection","infectiousPeriodDays","sort","a","b","meanR0Trajectory","resultsTrajectory","lower","middle","upper","percentile","trajectory","R0","mean","plotData"],"mappings":"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","sourcesContent":["import { AgeGroup } from '../.generated/latest/types'\nimport { AgeDistributionDatum, ScenarioFlat, SeverityDistributionDatum } from './types/Param.types'\nimport { AlgorithmResult, SimulationTimePoint, ExportedTimePoint, ModelParams } from './types/Result.types'\n\nimport { getPopulationParams, initializePopulation, withUncertainty } from './initialize'\nimport { collectTotals, evolve } from './model'\nimport { percentileTrajectory } from './results'\nimport { preparePlotData } from './preparePlotData'\n\nconst identity = (x: number) => x\n\nexport interface RunParams {\n  params: ScenarioFlat\n  severity: SeverityDistributionDatum[]\n  ageDistribution: AgeDistributionDatum[]\n}\n\nfunction simulate(\n  initialState: SimulationTimePoint,\n  params: ModelParams,\n  tMax: number,\n  ageGroups: AgeGroup[],\n  func: (x: number) => number,\n): ExportedTimePoint[] {\n  const dynamics = [initialState]\n  let currState = initialState\n\n  while (currState.time < tMax) {\n    currState = evolve(currState, params, currState.time + 1, func)\n    dynamics.push(currState)\n  }\n\n  return collectTotals(dynamics, ageGroups)\n}\n\nexport async function run({ params, severity, ageDistribution }: RunParams): Promise<AlgorithmResult> {\n  const tMin: number = new Date(params.simulationTimeRange.begin).getTime()\n  const tMax: number = new Date(params.simulationTimeRange.end).getTime()\n  const ageGroups = ageDistribution.map((d) => d.ageGroup)\n  const initialCases = params.initialNumberOfCases\n\n  const stochastic = withUncertainty(params)\n\n  let stochasticTrajectories: ExportedTimePoint[][] = []\n  let stochasticParams: ModelParams[] = []\n  if (stochastic) {\n    stochasticParams = getPopulationParams(params, severity, ageDistribution, false)\n    stochasticTrajectories = stochasticParams.map((modelParams) => {\n      const tmpPopulation = initializePopulation(modelParams.populationServed, initialCases, tMin, ageDistribution)\n      return simulate(tmpPopulation, modelParams, tMax, ageGroups, identity)\n    })\n  }\n  const deterministicParams = getPopulationParams(params, severity, ageDistribution, true)[0]\n  const population = initializePopulation(deterministicParams.populationServed, initialCases, tMin, ageDistribution)\n  const deterministicTrajectory = simulate(population, deterministicParams, tMax, ageGroups, identity)\n\n  const thresholds = [0.2, 0.8]\n  const idxs = thresholds.map((d) => Math.ceil((stochasticTrajectories.length - 1) * d))\n  const R0Trajectories = stochastic\n    ? deterministicTrajectory.map((d) => {\n        return {\n          t: d.time,\n          y: stochasticParams\n            .map((ModelParams) => ModelParams.rate.infection(d.time) * params.infectiousPeriodDays)\n            .sort((a, b) => a - b),\n        }\n      })\n    : []\n\n  const meanR0Trajectory = deterministicTrajectory.map((d) => {\n    return {\n      t: d.time,\n      y: deterministicParams.rate.infection(d.time) * params.infectiousPeriodDays,\n    }\n  })\n  const resultsTrajectory = {\n    lower: stochastic ? percentileTrajectory(stochasticTrajectories, 0.2) : deterministicTrajectory,\n    middle: deterministicTrajectory,\n    upper: stochastic ? percentileTrajectory(stochasticTrajectories, 0.8) : deterministicTrajectory,\n    percentile: {},\n  }\n  return {\n    trajectory: resultsTrajectory,\n    R0: {\n      mean: meanR0Trajectory,\n      lower: stochastic ? R0Trajectories.map((d) => ({ t: d.t, y: d.y[idxs[0]] })) : meanR0Trajectory,\n      upper: stochastic ? R0Trajectories.map((d) => ({ t: d.t, y: d.y[idxs[1]] })) : meanR0Trajectory,\n    },\n    plotData: preparePlotData(resultsTrajectory),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}