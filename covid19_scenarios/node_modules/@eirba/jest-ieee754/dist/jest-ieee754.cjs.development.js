'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ieee754 = require('@eirba/ieee754');
var fs = require('fs');
var jestSnapshot = require('jest-snapshot');

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var State = /*#__PURE__*/function () {
  function State(context) {
    this.currentTestName = context.currentTestName;
    this.snapshotState = context.snapshotState;
    this.error = context.error;
    this.incrementCounters();
    this.hasSnapshot = this.getSnapshot() !== undefined;
  }

  var _proto = State.prototype;

  _proto.incrementCounters = function incrementCounters() {
    this.snapshotState._counters.set(this.currentTestName, (this.snapshotState._counters.get(this.currentTestName) || 0) + 1);
  };

  _proto.markSnapshotsAsCheckedForTest = function markSnapshotsAsCheckedForTest() {
    this.snapshotState.markSnapshotsAsCheckedForTest(this.currentTestName);
  };

  _proto.getSnapshot = function getSnapshot() {
    return this.snapshotState._snapshotData[this.key];
  };

  _proto.setSnapshot = function setSnapshot(data) {
    this.snapshotState._snapshotData[this.key] = data;
  }
  /* This nested mess is derived the Jest snapshot matcher code:
   * https://github.com/facebook/jest/blob/4a59daa8715bde6a1b085ff7f4140f3a337045aa/packages/jest-snapshot/src/State.ts
   *
   * Which describes the conditions as follows:
   *  These are the conditions on when to write snapshots:
   * There's no snapshot file in a non-CI environment.
   * There is a snapshot file and we decided to update the snapshot.
   * There is a snapshot file, but it doesn't have this snaphsot.
   These are the conditions on when not to write snapshots:
   * The update flag is set to 'none'.
   * There's no snapshot file or a file without this snapshot on a CI environment.
   */
  ;

  _proto.couldAddSnapshot = function couldAddSnapshot() {
    return this.hasSnapshot && this.snapshotState._updateSnapshot === 'all' || (!this.hasSnapshot || !this.snapshotIsPersisted) && (this.snapshotState._updateSnapshot === 'new' || this.snapshotState._updateSnapshot === 'all');
  };

  _proto.updateTally = function updateTally(pass) {
    if (this.couldAddSnapshot()) {
      if (this.snapshotState._updateSnapshot === 'all') {
        if (!pass) {
          if (this.hasSnapshot) {
            this.snapshotState.updated++;
          } else {
            this.snapshotState.added++;
          }
        } else {
          this.snapshotState.matched++;
        }
      } else {
        this.snapshotState.added++;
      }
    } else if (!pass) {
      this.snapshotState.unmatched++;
    } else {
      this.snapshotState.matched++;
    }
  };

  _proto.addSnapshot = function addSnapshot(data) {
    var isInline = false;

    this.snapshotState._addSnapshot(this.key, data, {
      error: this.error,
      isInline: isInline
    });
  };

  _createClass(State, [{
    key: "count",
    get: function get() {
      return Number(this.snapshotState._counters.get(this.currentTestName));
    }
  }, {
    key: "key",
    get: function get() {
      return jestSnapshot.utils.testNameToKey(this.currentTestName, this.count);
    }
  }, {
    key: "snapshotIsPersisted",
    get: function get() {
      return fs.existsSync(this.snapshotState._snapshotPath);
    }
  }]);

  return State;
}();

function serialize(arr) {
  return JSON.stringify(arr);
}
/* This function will throw an exception if param is not defined. */


function deserialize(str) {
  return JSON.parse(str);
}
/* Catch failed deserialization and return an empty array to force a new snapshot */


function tryDeserialize(str) {
  try {
    return deserialize(str);
  } catch (_unused) {
    return [];
  }
}

function compare(want, got, maxUlp) {
  if (want.length !== got.length) {
    return false;
  }

  return want.every(function (_, idx) {
    return ieee754.ulpDistance(want[idx], got[idx]) <= maxUlp;
  });
}

function toBeCloseToArraySnapshot(received, maxUlp) {
  if (maxUlp === void 0) {
    maxUlp = BigInt(4);
  }

  var state = new State(this);
  var snapshot = state.getSnapshot();
  var expected = tryDeserialize(snapshot);
  var pass = compare(expected, received, maxUlp);
  state.markSnapshotsAsCheckedForTest();

  if (pass) {
    state.setSnapshot(serialize(received));
  }

  state.updateTally(pass);

  if (state.couldAddSnapshot()) {
    state.addSnapshot(serialize(received));
    return {
      message: function message() {
        return '';
      },
      pass: true
    };
  }

  if (!pass) {
    return {
      message: function message() {
        return "expected: " + expected + "\n received: " + received;
      },
      actual: serialize(received),
      count: state.count,
      expected: serialize(expected),
      key: state.key,
      pass: false
    };
  }

  return {
    message: function message() {
      return '';
    },
    actual: serialize(received),
    count: state.count,
    expected: '',
    key: state.key,
    pass: true
  };
}

function toBeCloseToNumber(got, want, maxUlp) {
  if (maxUlp === void 0) {
    maxUlp = BigInt(4);
  }

  var diff = ieee754.ulpDistance(want, got);
  var pass = diff <= maxUlp;

  if (pass) {
    return {
      message: function message() {
        return "received (" + got + ") and expected (" + want + ") have a ULP distance of " + diff + " which does not exceed the maximum ULP distance of " + maxUlp + ".";
      },
      pass: true
    };
  }

  return {
    message: function message() {
      return "received (" + got + ") and expected (" + want + ") have a ULP distance of " + diff + " ULP which exceeds maximum of " + maxUlp + ".";
    },
    pass: false
  };
}

exports.toBeCloseToArraySnapshot = toBeCloseToArraySnapshot;
exports.toBeCloseToNumber = toBeCloseToNumber;
//# sourceMappingURL=jest-ieee754.cjs.development.js.map
