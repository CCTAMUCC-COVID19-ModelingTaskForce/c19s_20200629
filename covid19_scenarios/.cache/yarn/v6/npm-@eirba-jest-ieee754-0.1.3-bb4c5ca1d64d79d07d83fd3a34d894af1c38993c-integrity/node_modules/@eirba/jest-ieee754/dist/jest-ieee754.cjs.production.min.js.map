{"version":3,"file":"jest-ieee754.cjs.production.min.js","sources":["../src/state.ts","../src/toBeCloseToArraySnapshot.ts","../src/toBeCloseToNumber.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/* Because Jest StateSnapshot uses them. */\n\n/* eslint-disable import/no-extraneous-dependencies */\n/* tslint:disable:no-implicit-dependencies */\n/* Because this is Jest extension, and Jest is present. */\n\nimport * as fs from 'fs';\nimport { utils } from 'jest-snapshot';\nimport { Context, SnapshotState } from './types';\n\nexport default class State {\n  private currentTestName: string;\n  private snapshotState: SnapshotState;\n  private error?: Error;\n  private hasSnapshot: boolean;\n\n  private incrementCounters() {\n    this.snapshotState._counters.set(\n      this.currentTestName,\n      (this.snapshotState._counters.get(this.currentTestName) || 0) + 1\n    );\n  }\n\n  get count() {\n    return Number(this.snapshotState._counters.get(this.currentTestName));\n  }\n\n  get key() {\n    return utils.testNameToKey(this.currentTestName, this.count);\n  }\n\n  markSnapshotsAsCheckedForTest() {\n    this.snapshotState.markSnapshotsAsCheckedForTest(this.currentTestName);\n  }\n\n  get snapshotIsPersisted() {\n    return fs.existsSync(this.snapshotState._snapshotPath);\n  }\n\n  constructor(context: Context) {\n    this.currentTestName = context.currentTestName;\n    this.snapshotState = context.snapshotState;\n    this.error = context.error;\n\n    this.incrementCounters();\n\n    this.hasSnapshot = this.getSnapshot() !== undefined;\n  }\n\n  getSnapshot() {\n    return this.snapshotState._snapshotData[this.key];\n  }\n\n  setSnapshot(data: string) {\n    this.snapshotState._snapshotData[this.key] = data;\n  }\n\n  /* This nested mess is derived the Jest snapshot matcher code:\n   * https://github.com/facebook/jest/blob/4a59daa8715bde6a1b085ff7f4140f3a337045aa/packages/jest-snapshot/src/State.ts\n   *\n   * Which describes the conditions as follows:\n   *  These are the conditions on when to write snapshots:\n   * There's no snapshot file in a non-CI environment.\n   * There is a snapshot file and we decided to update the snapshot.\n   * There is a snapshot file, but it doesn't have this snaphsot.\n   These are the conditions on when not to write snapshots:\n   * The update flag is set to 'none'.\n   * There's no snapshot file or a file without this snapshot on a CI environment.\n   */\n  couldAddSnapshot(): boolean {\n    return (\n      (this.hasSnapshot && this.snapshotState._updateSnapshot === 'all') ||\n      ((!this.hasSnapshot || !this.snapshotIsPersisted) &&\n        (this.snapshotState._updateSnapshot === 'new' ||\n          this.snapshotState._updateSnapshot === 'all'))\n    );\n  }\n\n  updateTally(pass: boolean) {\n    if (this.couldAddSnapshot()) {\n      if (this.snapshotState._updateSnapshot === 'all') {\n        if (!pass) {\n          if (this.hasSnapshot) {\n            this.snapshotState.updated++;\n          } else {\n            this.snapshotState.added++;\n          }\n        } else {\n          this.snapshotState.matched++;\n        }\n      } else {\n        this.snapshotState.added++;\n      }\n    } else if (!pass) {\n      this.snapshotState.unmatched++;\n    } else {\n      this.snapshotState.matched++;\n    }\n  }\n\n  addSnapshot(data: string) {\n    const isInline = false;\n\n    this.snapshotState._addSnapshot(this.key, data, {\n      error: this.error,\n      isInline,\n    });\n  }\n}\n","import { ulpDistance } from '@eirba/ieee754';\nimport { Context } from './types';\nimport State from './state';\n\nfunction serialize(arr: number[]): string {\n  return JSON.stringify(arr);\n}\n\n/* This function will throw an exception if param is not defined. */\nfunction deserialize(str: string): number[] {\n  return JSON.parse(str);\n}\n\n/* Catch failed deserialization and return an empty array to force a new snapshot */\nfunction tryDeserialize(str: string): number[] {\n  try {\n    return deserialize(str);\n  } catch {\n    return [];\n  }\n}\n\nfunction compare(want: number[], got: number[], maxUlp: bigint): boolean {\n  if (want.length !== got.length) {\n    return false;\n  }\n\n  return want.every((_, idx) => ulpDistance(want[idx], got[idx]) <= maxUlp);\n}\n\nexport default function toBeCloseToArraySnapshot(\n  this: Context,\n  received: number[],\n  maxUlp: bigint = BigInt(4)\n) {\n  const state = new State(this);\n\n  const snapshot = state.getSnapshot();\n  const expected = tryDeserialize(snapshot);\n\n  const pass = compare(expected, received, maxUlp);\n\n  state.markSnapshotsAsCheckedForTest();\n\n  if (pass) {\n    state.setSnapshot(serialize(received));\n  }\n\n  state.updateTally(pass);\n\n  if (state.couldAddSnapshot()) {\n    state.addSnapshot(serialize(received));\n\n    return {\n      message: () => '',\n      pass: true,\n    };\n  }\n\n  if (!pass) {\n    return {\n      message: () => `expected: ${expected}\\n received: ${received}`,\n      actual: serialize(received),\n      count: state.count,\n      expected: serialize(expected),\n      key: state.key,\n      pass: false,\n    };\n  }\n\n  return {\n    message: () => '',\n    actual: serialize(received),\n    count: state.count,\n    expected: '',\n    key: state.key,\n    pass: true,\n  };\n}\n","import { ulpDistance } from '@eirba/ieee754';\n\nexport default function toBeCloseToNumber(\n  got: number,\n  want: number,\n  maxUlp: bigint = BigInt(4)\n) {\n  const diff = ulpDistance(want, got);\n  const pass = diff <= maxUlp;\n\n  if (pass) {\n    return {\n      message: () =>\n        `received (${got}) and expected (${want}) have a ULP distance of ${diff} which does not exceed the maximum ULP distance of ${maxUlp}.`,\n      pass: true,\n    };\n  }\n  return {\n    message: () =>\n      `received (${got}) and expected (${want}) have a ULP distance of ${diff} ULP which exceeds maximum of ${maxUlp}.`,\n    pass: false,\n  };\n}\n"],"names":["State","context","currentTestName","snapshotState","error","incrementCounters","hasSnapshot","undefined","this","getSnapshot","_counters","set","get","markSnapshotsAsCheckedForTest","_snapshotData","key","setSnapshot","data","couldAddSnapshot","_updateSnapshot","snapshotIsPersisted","updateTally","pass","matched","updated","added","unmatched","addSnapshot","_addSnapshot","isInline","Number","utils","testNameToKey","count","fs","_snapshotPath","serialize","arr","JSON","stringify","received","maxUlp","BigInt","state","expected","str","parse","deserialize","tryDeserialize","want","got","length","every","_","idx","ulpDistance","compare","message","actual","diff"],"mappings":"+IAWqBA,wBA6BPC,QACLC,gBAAkBD,EAAQC,qBAC1BC,cAAgBF,EAAQE,mBACxBC,MAAQH,EAAQG,WAEhBC,yBAEAC,iBAAqCC,IAAvBC,KAAKC,2CA9BlBJ,kBAAA,gBACDF,cAAcO,UAAUC,IAC3BH,KAAKN,iBACJM,KAAKL,cAAcO,UAAUE,IAAIJ,KAAKN,kBAAoB,GAAK,MAYpEW,8BAAA,gBACOV,cAAcU,8BAA8BL,KAAKN,oBAiBxDO,YAAA,kBACSD,KAAKL,cAAcW,cAAcN,KAAKO,QAG/CC,YAAA,SAAYC,QACLd,cAAcW,cAAcN,KAAKO,KAAOE,KAe/CC,iBAAA,kBAEKV,KAAKF,aAAsD,QAAvCE,KAAKL,cAAcgB,mBACrCX,KAAKF,cAAgBE,KAAKY,uBACa,QAAvCZ,KAAKL,cAAcgB,iBACqB,QAAvCX,KAAKL,cAAcgB,oBAI3BE,YAAA,SAAYC,GACNd,KAAKU,mBACoC,QAAvCV,KAAKL,cAAcgB,gBAChBG,OAOEnB,cAAcoB,UANff,KAAKF,iBACFH,cAAcqB,eAEdrB,cAAcsB,aAMlBtB,cAAcsB,QAEXH,OAGLnB,cAAcoB,eAFdpB,cAAcuB,eAMvBC,YAAA,SAAYV,QAGLd,cAAcyB,aAAapB,KAAKO,IAAKE,EAAM,CAC9Cb,MAAOI,KAAKJ,MACZyB,UAJe,4CA7EVC,OAAOtB,KAAKL,cAAcO,UAAUE,IAAIJ,KAAKN,qDAI7C6B,QAAMC,cAAcxB,KAAKN,gBAAiBM,KAAKyB,0DAQ/CC,aAAc1B,KAAKL,cAAcgC,6MCjC5C,SAASC,EAAUC,UACVC,KAAKC,UAAUF,6CA2BtBG,EACAC,YAAAA,IAAAA,EAAiBC,OAAO,QAElBC,EAAQ,IAAI3C,EAAMQ,MAGlBoC,EAxBR,SAAwBC,cALxB,SAAqBA,UACZP,KAAKQ,MAAMD,GAMTE,CAAYF,GACnB,eACO,IAoBQG,CADAL,EAAMlC,eAGjBa,EAlBR,SAAiB2B,EAAgBC,EAAeT,UAC1CQ,EAAKE,SAAWD,EAAIC,QAIjBF,EAAKG,OAAM,SAACC,EAAGC,UAAQC,cAAYN,EAAKK,GAAMJ,EAAII,KAASb,KAarDe,CAAQZ,EAAUJ,EAAUC,UAEzCE,EAAM9B,gCAEFS,GACFqB,EAAM3B,YAAYoB,EAAUI,IAG9BG,EAAMtB,YAAYC,GAEdqB,EAAMzB,oBACRyB,EAAMhB,YAAYS,EAAUI,IAErB,CACLiB,QAAS,iBAAM,IACfnC,MAAM,IAILA,EAWE,CACLmC,QAAS,iBAAM,IACfC,OAAQtB,EAAUI,GAClBP,MAAOU,EAAMV,MACbW,SAAU,GACV7B,IAAK4B,EAAM5B,IACXO,MAAM,GAhBC,CACLmC,QAAS,8BAAmBb,kBAAwBJ,GACpDkB,OAAQtB,EAAUI,GAClBP,MAAOU,EAAMV,MACbW,SAAUR,EAAUQ,GACpB7B,IAAK4B,EAAM5B,IACXO,MAAM,uCC/DV4B,EACAD,EACAR,YAAAA,IAAAA,EAAiBC,OAAO,QAElBiB,EAAOJ,cAAYN,EAAMC,UAClBS,GAAQlB,EAGZ,CACLgB,QAAS,8BACMP,qBAAsBD,8BAAgCU,wDAA0DlB,OAC/HnB,MAAM,GAGH,CACLmC,QAAS,8BACMP,qBAAsBD,8BAAgCU,mCAAqClB,OAC1GnB,MAAM"}