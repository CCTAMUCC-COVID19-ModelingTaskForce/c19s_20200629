{
  "manifest": {
    "name": "redux-testkit",
    "version": "1.0.6",
    "publishConfig": {
      "registry": "https://registry.npmjs.org/"
    },
    "description": "Complete and opinionated testkit for testing Redux projects (reducers, selectors, actions, thunks)",
    "author": {
      "name": "Yedidya Kennard",
      "email": "yedidyak@gmail.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/wix/redux-testkit.git"
    },
    "main": "dist/index.js",
    "scripts": {
      "build": "rm -rf dist && babel src --presets=stage-0,latest,react -d dist",
      "lint": "eslint src test",
      "pretest": "npm run lint",
      "test": "jest",
      "prepublish": "npm run build"
    },
    "dependencies": {
      "lodash": "^4.0.0",
      "babel-polyfill": "^6.8.0"
    },
    "devDependencies": {
      "app-root-path": "^1.0.0",
      "babel-cli": "^6.8.0",
      "babel-core": "^6.8.0",
      "babel-eslint": "^6.0.4",
      "babel-jest": "^19.0.0",
      "babel-preset-es2015": "^6.24.0",
      "babel-preset-latest": "^6.24.0",
      "babel-preset-react": "^6.23.0",
      "babel-preset-react-native": "^1.9.0",
      "babel-preset-stage-0": "^6.22.0",
      "babel-register": "^6.8.0",
      "eslint": "^2.5.1",
      "eslint-plugin-babel": "^3.0.0",
      "eslint-plugin-react": "^4.2.3",
      "eslint-plugin-react-native": "^1.0.0",
      "jasmine": "2.4.1",
      "jasmine-expect": "^2.0.2",
      "jasmine-reporters": "^2.1.1",
      "jasmine-spec-reporter": "^2.4.0",
      "jest": "^19.0.2",
      "proxyquire": "1.7.4",
      "redux": "^3.6.0",
      "redux-thunk": "^2.2.0",
      "regenerator-runtime": "^0.10.3",
      "seamless-immutable": "^7.1.1"
    },
    "_registry": "npm",
    "_loc": "/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/.cache/yarn/v6/npm-redux-testkit-1.0.6-58b2b389455be927a4eff796060a17eee89d9393-integrity/node_modules/redux-testkit/package.json",
    "readmeFilename": "README.md",
    "readme": "# Redux Testkit\n> Complete and opinionated testkit for testing Redux projects (reducers, selectors, actions, thunks)\n\n* [Installation](#installation)\n* [Recipe - Unit testing reducers](#recipe---unit-testing-reducers)\n* [Recipe - Unit testing selectors](#recipe---unit-testing-selectors)\n* [Recipe - Unit testing thunks](#recipe---unit-testing-thunks)\n* [Recipe - Integration tests for the entire store](#recipe---integration-tests-for-the-entire-store)\n* [Building and testing this library](#building-and-testing-this-library)\n\n<br>\n\n## What tests are we going to write?\n\n* *Unit tests* for [reducers](http://redux.js.org/docs/basics/Reducers.html) - test recipe [here](#recipe---unit-testing-reducers)\n* *Unit tests* for [selectors](http://redux.js.org/docs/recipes/ComputingDerivedData.html) - test recipe [here](#recipe---unit-testing-selectors)\n* *Unit tests* for [action handlers (thunks)](https://github.com/gaearon/redux-thunk) - test recipe [here](#recipe---unit-testing-thunks)\n* *Integration tests* for the entire [store](http://redux.js.org/docs/basics/Store.html) - test recipe [here](#recipe---integration-tests-for-the-entire-store)\n\nThis library mostly provides syntactic sugar and makes testing Redux fun with less boilerplate. You can naturally test all Redux constructs without this library, but you will miss out on features like automatic immutability checks.\n\n<br>\n\n## Installation\n\n* Install the package from npm\n\n```\nnpm install redux-testkit --save-dev\n```\n\n* Make sure you have a test runner installed, we recommend [jest](https://facebook.github.io/jest/docs/getting-started.html)\n\n```\nnpm install jest --save-dev\n```\n\n<br>\n\n## Recipe - Unit testing reducers\n\n```js\nimport { Reducer } from 'redux-testkit';\nimport uut from '../reducer';\n\ndescribe('counter reducer', () => {\n\n  it('should have initial state', () => {\n    expect(uut()).toEqual({ counter: 0 });\n  });\n\n  it('should handle INCREMENT action on initial state', () => {\n    const action = { type: 'INCREMENT' };\n    const result = { counter: 1 };\n    Reducer(uut).expect(action).toReturnState(result);\n  });\n\n  it('should handle INCREMENT action on existing state', () => {\n    const action = { type: 'INCREMENT' };\n    const state = { counter: 1 };\n    const result = { counter: 2 };\n    Reducer(uut).withState(state).expect(action).toReturnState(result);\n  });\n\n});\n```\n\nA redux reducer is a pure function that takes an action object, with a `type` field, and changes the state. In almost every case the state object itself must remain immutable.\n\n#### `Reducer(reducer).withState(state).expect(action).toReturnState(result)`\n\n* Runs the `reducer` on current `state` providing an `action`. Calling `withState()` is optional, if not provided, initial state is used. Makes sure the returned state is `result`.\n\n* Also verifies immutability - that `state` did not mutate. [Why is this important? see example bug](BUG-EXAMPLES.md#reducer)\n\n> [See some examples of this API](API-EXAMPLES.md#reducerreducerwithstatestateexpectactiontoreturnstateresult)\n\n#### `Reducer(reducer).withState(state).expect(action).toChangeInState(changes)`\n\n* Runs the `reducer` on current `state` providing an `action`. Calling `withState()` is optional, if not provided, initial state is used. Makes sure the part that changed in the returned state matches `changes` and the rest of the state hasn't changed. The format of `changes` is partial state, even a deep internal object - it is compared to returned state after [merging](https://lodash.com/docs/#merge) the changes with the original state (objects are deep merged, arrays are replaced).\n\n* Also verifies immutability of the `state`.\n\n> *The added value of this API compared to `toReturnState` is when your state object is very large and you prefer to reduce the boilerplate of preparing the entire `result` by yourself.*\n\n> [See some examples of this API](API-EXAMPLES.md#reducerreducerwithstatestateexpectactiontochangeinstatechanges)\n\n#### `Reducer(reducer).withState(state).execute(action)`\n\n* Runs the `reducer` on current `state` providing an `action`. Calling `withState()` is optional, if not provided, initial state is used.\n\n* Returns the returned state so you can run expectations manually. It's not recommended to use this API directly because you usually won't verify that parts in the returned state that were not supposed to change, indeed did not change.\n\n* Also verifies immutability of the `state`.\n\n> *The added value of this API compared to the others is that it allows you to run your own custom expectations (which isn't recommended).*\n\n> [See some examples of this API](API-EXAMPLES.md#reducerreducerwithstatestateexecuteaction)\n\n<br>\n\n## Recipe - Unit testing selectors\n\n```js\nimport { Selector } from 'redux-testkit';\nimport * as uut from '../reducer';\n\ndescribe('numbers selectors', () => {\n\n  it('should select integers from numbers state', () => {\n    const state = { numbers: [1, 2.2, 3.14, 4, 5.75, 6] };\n    const result = [1, 4, 6];\n    Selector(uut.getIntegers).expect(state).toReturn(result);\n  });\n\n});\n```\n\nA redux selector is a pure function that takes the state and computes some derivation from it. This operation is read-only and the state object itself must not change.\n\n#### `Selector(selector).expect(state, ...args).toReturn(result)`\n\n* Runs the `selector` function on a given `state`. If the selector takes more arguments, provide them at `...args` (the state is always assumed to be the first argument of a selector). Makes sure the returned result is `result`.\n\n* Also verifies that `state` did not mutate. [Why is this important? see example bug](BUG-EXAMPLES.md#selector)\n\n> [See some examples of this API](API-EXAMPLES.md#selectorselectorexpectstate-argstoreturnresult)\n\n#### `Selector(selector).execute(state, ...args)`\n\n* Runs the `selector` function on a given `state`. If the selector takes more arguments, provide them at `...args` (the state is always assumed to be the first argument of a selector).\n\n* Returns the returned state so you can run expectations manually.\n\n* Also verifies that `state` did not mutate.\n\n> *The added value of this API compared to the others is that it allows you to run your own custom expectations.*\n\n> [See some examples of this API](API-EXAMPLES.md#selectorselectorexecutestate-args)\n\n<br>\n\n## Recipe - Unit testing thunks\n\n```js\nimport { Thunk } from 'redux-testkit';\nimport * as uut from '../actions';\nimport redditService from '../../../services/reddit';\njest.mock('../../../services/reddit');\n\ndescribe('posts actions', () => {\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n  });\n\n  it('should clear all posts', () => {\n    const dispatches = Thunk(uut.clearPosts).execute();\n    expect(dispatches.length).toBe(1);\n    expect(dispatches[0].getAction()).toEqual({ type: 'POSTS_UPDATED', posts: [] });\n  });\n\n  it('should fetch posts from server', async () => {\n    redditService.getPostsBySubreddit.mockReturnValueOnce(['post1', 'post2']);\n    const dispatches = await Thunk(uut.fetchPosts).execute();\n    expect(dispatches.length).toBe(3);\n    expect(dispatches[0].getAction()).toEqual({ type: 'POSTS_LOADING', loading: true });\n    expect(dispatches[1].getAction()).toEqual({ type: 'POSTS_UPDATED', posts: ['post1', 'post2'] });\n    expect(dispatches[2].getAction()).toEqual({ type: 'POSTS_LOADING', loading: false });\n  });\n\n  it('should filter posts', () => {\n    const state = { loading: false, posts: ['funny1', 'scary2', 'funny3'] };\n    const dispatches = Thunk(uut.filterPosts).withState(state).execute('funny');\n    expect(dispatches.length).toBe(1);\n    expect(dispatches[0].getAction()).toEqual({ type: 'POSTS_UPDATED', posts: ['funny1', 'funny3'] });\n  });\n\n});\n```\n\nA redux thunk wraps a synchronous or asynchronous function that performs an action. It can dispatch other actions (either plain objects or other thunks). It can also perform side effects like accessing servers.\n\n#### `Thunk(thunk).withState(state).execute(...args)`\n\n* Runs the thunk `thunk` on current `state` given optional arguments `...args`. Calling `withState()` is optional, no need to provide it if the internal thunk implementation doesn't call `getState()`.\n\n* Returns an array of dispatches performed by the thunk (shallow, these dispatches are not executed). You can run expectations over them manually. If the tested thunk is asynchronous, `await` on the result to get the actual dispatches array. If it's synchronous, you can use the return value directly without `await`.\n\n* Also verifies that `state` did not mutate. [Why is this important? see example bug](BUG-EXAMPLES.md#thunk)\n\n> [See some examples of this API](API-EXAMPLES.md#thunkthunkwithstatestateexecuteargs)\n\n##### Available expectations over a dispatch\n\n```js\n// when a plain object action was dispatched\nexpect(dispatches[0].isPlainObject()).toBe(true);\nexpect(dispatches[0].getType()).toEqual('LOADING_CHANGED');\nexpect(dispatches[0].getAction()).toEqual({ type: 'LOADING_CHANGED', loading: true });\n\n// when another thunk was dispatched\nexpect(dispatches[0].isFunction()).toBe(true);\nexpect(dispatches[0].getName()).toEqual('refreshSession'); // the function name, see note below\n```\n\n##### Being able to expect dispatched thunk function names\n\nThis is relevant when the tested thunk dispatches another thunk. In order to be able to test the name of the thunk that was dispatched, you will have to provide an explicit name to the internal anonymous function in the thunk implementation. For example:\n\n```js\nexport function refreshSession() {\n  return async function refreshSession(dispatch, getState) {\n    // ...\n  };\n}\n```\n\n##### Limitations when testing thunks that dispatch other thunks\n\n* If the tested thunk dispatches another thunk, the other thunk is not executed. Different thunks should be considered as different units. Executing another unit should be part of an [integration test](#recipe---integration-tests-for-the-entire-store), not a unit test.\n\n* If the tested thunk dispatches another thunk, you cannot set expectations on the arguments given to the other thunk. Different thunks should be considered as different units. Testing the interfaces between them should be part of an [integration test](#recipe---integration-tests-for-the-entire-store), not a unit test.\n\n* If the tested thunk dispatches another thunk, you cannot mock the return value of the other thunk. Relying in your implementation on the return value of another thunk is considered bad practice. If you must test that, you should probably be changing your implementation.\n\n> These limitations may seem annoying, but they stem from best practices. If they disrupt your test, it's usually a sign of a code smell in your implementation. Fix the implementation, don't fight to test a bad practice.\n\n<br>\n\n## Recipe - Integration tests for the entire store\n\n```js\nimport { createStore, applyMiddleware, combineReducers } from 'redux';\nimport thunk from 'redux-thunk';\nimport { FlushThunks } from 'redux-testkit';\n\nimport * as reducers from '../reducers';\nimport * as uut from '../posts/actions';\nimport * as postsSelectors from '../posts/reducer';\nimport redditService from '../../services/reddit';\njest.mock('../../services/reddit');\n\ndescribe('posts store integration', () => {\n\n  let flushThunks, store;\n\n  beforeEach(() => {\n    jest.resetAllMocks();\n    // create a redux store with flushThunks added as the first middleware\n    flushThunks = FlushThunks.createMiddleware();\n    store = createStore(combineReducers(reducers), applyMiddleware(flushThunks, thunk));\n  });\n\n  it('should select posts', () => {\n    expect(postsSelectors.getSelectedPost(store.getState())).toEqual([]);\n    store.dispatch(uut.selectPost('post1'));\n    expect(postsSelectors.getSelectedPost(store.getState())).toEqual(['post1']);\n    store.dispatch(uut.selectPost('post2'));\n    expect(postsSelectors.getSelectedPost(store.getState())).toEqual(['post1', 'post2']);\n  });\n\n  it('should fetch posts from server', async () => {\n    redditService.getPostsBySubreddit.mockReturnValueOnce(['post1', 'post2']);\n    expect(postsSelectors.getPostsLoading(store.getState())).toBe(false);\n    expect(postsSelectors.getPosts(store.getState())).toEqual([]);\n    await store.dispatch(uut.fetchPosts());\n    expect(postsSelectors.getPostsLoading(store.getState())).toBe(false);\n    expect(postsSelectors.getPosts(store.getState())).toEqual(['post1', 'post2']);\n  });\n\n  it('should test a thunk that dispatches another thunk', async () => {\n    expect(postsSelectors.isForeground(store.getState())).toBe(false);\n    await store.dispatch(uut.initApp()); // this dispathces thunk appOnForeground\n    await flushThunks.flush(); // wait until all async thunks resolve\n    expect(postsSelectors.isForeground(store.getState())).toBe(true);\n  });\n\n});\n```\n\nIntegration test for the entire store creates a real redux store with an extra flushThunks middleware. Test starts by dispatching an action / thunk. Expectations are set over the final state using selectors.\n\n#### `flushThunks = FlushThunks.createMiddleware()`\n\n* Creates `flushThunks` middleware which should be applied to the store on creation. This middleware is useful for the case where one thunk dispatches another thunk. It allows to wait until all of the thunk promises have been resolved.\n\n* Returns a `flushThunks` instance which has the following methods:\n\n##### `flushThunks.flush()`\n\n* Flushes all asynchronous thunks. Run `await` on this method to wait until all dispatched thunk promises are resolved.\n\n##### `flushThunks.reset()`\n\n* Call this method to reset the list of thunk promises observed by `flushThunks`.\n\n<br>\n\n## Building and testing this library\n\nThis section is relevant only if you want to contribute to this library or build it locally.\n\n* Install and build\n\n```\nnpm install\nnpm run build\n```\n\n* Run lint and tests\n\n```\nnpm run test\n```\n\n<br>\n\n## License\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) 2016 Wix.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/redux-testkit/-/redux-testkit-1.0.6.tgz#58b2b389455be927a4eff796060a17eee89d9393",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/redux-testkit/-/redux-testkit-1.0.6.tgz",
    "hash": "58b2b389455be927a4eff796060a17eee89d9393",
    "integrity": "sha1-WLKziUVb6Sek7/eWBgoX7uidk5M=",
    "registry": "npm",
    "packageName": "redux-testkit",
    "cacheIntegrity": "sha512-Poym2JNvwLE1ie0v+vQ6CcvGvjOumDbEwcdree3BW7Ct2wiEVqa+fzgrprowT6Vdb2QjjrLrXOWBlOLDK8L6tA== sha1-WLKziUVb6Sek7/eWBgoX7uidk5M="
  },
  "registry": "npm",
  "hash": "58b2b389455be927a4eff796060a17eee89d9393"
}