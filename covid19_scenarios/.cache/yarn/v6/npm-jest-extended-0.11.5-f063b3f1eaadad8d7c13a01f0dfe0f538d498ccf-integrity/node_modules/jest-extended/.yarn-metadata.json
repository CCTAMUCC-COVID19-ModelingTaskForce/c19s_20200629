{
  "manifest": {
    "name": "jest-extended",
    "version": "0.11.5",
    "description": "Additional Jest matchers",
    "main": "dist/index.js",
    "types": "types/index.d.ts",
    "files": [
      "dist",
      "README.md",
      "LICENSE",
      "types/index.d.ts"
    ],
    "scripts": {
      "build": "babel src -d dist --ignore *.test.js",
      "lint": "eslint src",
      "lint:fix": "yarn lint -- --fix",
      "prepublishOnly": "yarn build",
      "precommit": "lint-staged",
      "prettier": "prettier 'src/**/*.js' --write --single-quote=true --print-width=120",
      "test": "jest",
      "test:coverage": "yarn test -- --coverage",
      "test:report": "codecov",
      "test:watch": "yarn test -- --watch"
    },
    "keywords": [
      "jest",
      "matchers",
      "extend",
      "extended",
      "test",
      "testing",
      "assertions"
    ],
    "author": {
      "name": "Matt Phillips",
      "email": "matt@mattphillips.io",
      "url": "mattphillips.io"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/jest-community/jest-extended.git"
    },
    "devDependencies": {
      "@types/jest": "^23.3.2",
      "babel-cli": "^6.26.0",
      "babel-core": "^6.26.0",
      "babel-eslint": "^8.0.1",
      "babel-jest": "^23.0.1",
      "babel-jest-assertions": "^0.1.0",
      "babel-plugin-gwt": "^1.0.0",
      "babel-plugin-transform-async-to-generator": "^6.24.1",
      "babel-plugin-transform-es2015-modules-commonjs": "^6.26.0",
      "babel-plugin-transform-object-rest-spread": "^6.26.0",
      "codecov": "^3.0.0",
      "eslint": "^4.9.0",
      "eslint-plugin-import": "^2.8.0",
      "eslint-plugin-jest": "^21.2.0",
      "husky": "^0.14.3",
      "import-all.macro": "^2.0.3",
      "jest": "^23.0.1",
      "jest-each": "^0.5.0",
      "jest-watch-typeahead": "^0.2.0",
      "lint-staged": "^6.0.0",
      "prettier": "^1.7.4",
      "pretty-format": "^22.1.0"
    },
    "dependencies": {
      "expect": "^24.1.0",
      "jest-get-type": "^22.4.3",
      "jest-matcher-utils": "^22.0.0"
    },
    "lint-staged": {
      "*.js": [
        "yarn prettier",
        "git add"
      ]
    },
    "jest": {
      "testEnvironment": "node",
      "testPathIgnorePatterns": [
        "/node_modules/",
        "/fixtures/"
      ],
      "coveragePathIgnorePatterns": [
        "/node_modules/"
      ],
      "snapshotSerializers": [
        "pretty-format/build/plugins/convert_ansi.js"
      ],
      "coverageThreshold": {
        "global": {
          "branches": 100,
          "functions": 100,
          "lines": 100,
          "statements": 100
        }
      },
      "watchPlugins": [
        "jest-watch-typeahead/filename",
        "jest-watch-typeahead/testname"
      ]
    },
    "babel": {
      "plugins": [
        "babel-plugin-transform-es2015-modules-commonjs",
        "transform-object-rest-spread",
        "transform-async-to-generator",
        "babel-jest-assertions",
        "gwt",
        "macros"
      ]
    },
    "_registry": "npm",
    "_loc": "/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/.cache/yarn/v6/npm-jest-extended-0.11.5-f063b3f1eaadad8d7c13a01f0dfe0f538d498ccf-integrity/node_modules/jest-extended/package.json",
    "readmeFilename": "README.md",
    "readme": "<div align=\"center\">\n  <h1>jest-extended</h1>\n\n  üÉèüí™\n\n  Additional Jest matchers\n</div>\n\n<hr />\n\n[![Build Status](https://img.shields.io/travis/jest-community/jest-extended.svg?style=flat-square)](https://travis-ci.org/jest-community/jest-extended)\n[![Code Coverage](https://img.shields.io/codecov/c/github/jest-community/jest-extended.svg?style=flat-square)](https://codecov.io/github/jest-community/jest-extended)\n[![version](https://img.shields.io/npm/v/jest-extended.svg?style=flat-square)](https://www.npmjs.com/package/jest-extended)\n[![downloads](https://img.shields.io/npm/dm/jest-extended.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-extended&from=2017-09-14)\n[![MIT License](https://img.shields.io/npm/l/jest-extended.svg?style=flat-square)](https://github.com/jest-community/jest-extended/blob/master/LICENSE)\n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)\n[![Roadmap](https://img.shields.io/badge/%F0%9F%93%94-roadmap-CD9523.svg?style=flat-square)](https://github.com/jest-community/jest-extended/blob/master/docs/ROADMAP.md)\n[![Examples](https://img.shields.io/badge/%F0%9F%92%A1-examples-ff615b.svg?style=flat-square)](https://github.com/jest-community/jest-extended/blob/master/docs/EXAMPLES.md)\n\n## Problem\n\nJest is an amazing test runner and has some awesome assertion APIs built in by default. However there are times when\nhaving more specific matchers (assertions) would be far more convenient.\n\n## Solution\n\njest-extended aims to add additional matchers to Jest's default ones making it easy to test everything üôå\n\n## Contributing\n\nIf you've come here to help contribute - Thanks! Take a look at the [contributing](/CONTRIBUTING.md) docs as a way of getting started.\n\n---\n\n- [Problem](#problem)\n- [Solution](#solution)\n- [Contributing](#contributing)\n- [Installation](#installation)\n- [Setup](#setup)\n- [Asymmetric matchers](#asymmetric-matchers)\n- [API](#api)\n    - [.pass(message)](#passmessage)\n    - [.fail(message)](#failmessage)\n    - [.toBeEmpty()](#tobeempty)\n    - [.toBeOneOf([members])](#tobeoneofmembers)\n    - [.toBeNil()](#tobenil)\n    - [.toSatisfy(predicate)](#tosatisfypredicate)\n  - [Array](#array)\n    - [.toBeArray()](#tobearray)\n    - [.toBeArrayOfSize()](#tobearrayofsize)\n    - [.toIncludeAllMembers([members])](#toincludeallmembersmembers)\n    - [.toIncludeAnyMembers([members])](#toincludeanymembersmembers)\n    - [.toIncludeSameMembers([members])](#toincludesamemembersmembers)\n    - [.toSatisfyAll(predicate)](#tosatisfyallpredicate)\n  - [Boolean](#boolean)\n    - [.toBeBoolean()](#tobeboolean)\n    - [.toBeTrue()](#tobetrue)\n    - [.toBeFalse()](#tobefalse)\n  - [Date](#date)\n    - [.toBeDate()](#tobedate)\n    - [.toBeValidDate()](#tobevaliddate)\n    - [.toBeAfter(date)](#tobeafterdate)\n    - [.toBeBefore(date)](#tobebeforedate)\n    - Further proposals in [#117](https://github.com/jest-community/jest-extended/issues/117) PRs welcome\n  - [Function](#function)\n    - [.toBeFunction()](#tobefunction)\n    - [.toThrowWithMessage()](#tothrowwithmessagetype-message)\n  - [Mock](#mock)\n    - [.toHaveBeenCalledBefore()](#tohavebeencalledbefore)\n    - [.toHaveBeenCalledAfter()](#tohavebeencalledafter)\n  - [Number](#number)\n    - [.toBeNumber()](#tobenumber)\n    - [.toBeNaN()](#tobenan)\n    - [.toBeFinite()](#tobefinite)\n    - [.toBePositive()](#tobepositive)\n    - [.toBeNegative()](#tobenegative)\n    - [.toBeEven()](#tobeeven)\n    - [.toBeOdd()](#tobeodd)\n    - [.toBeWithin(start, end)](#tobewithinstart-end)\n  - [Object](#object)\n    - [.toBeObject()](#tobeobject)\n    - [.toContainKey(key)](#tocontainkeykey)\n    - [.toContainKeys([keys])](#tocontainkeyskeys)\n    - [.toContainAllKeys([keys])](#tocontainallkeyskeys)\n    - [.toContainAnyKeys([keys])](#tocontainanykeyskeys)\n    - [.toContainValue(value)](#tocontainvaluevalue)\n    - [.toContainValues([values])](#tocontainvaluesvalues)\n    - [.toContainAllValues([values])](#tocontainallvaluesvalues)\n    - [.toContainAnyValues([values])](#tocontainanyvaluesvalues)\n    - [.toContainEntry([key, value])](#tocontainentrykey-value)\n    - [.toContainEntries([[key, value]])](#tocontainentrieskey-value)\n    - [.toContainAllEntries([[key, value]])](#tocontainallentrieskey-value)\n    - [.toContainAnyEntries([[key, value]])](#tocontainanyentrieskey-value)\n    - [.toBeExtensible()](#tobeextensible)\n    - [.toBeFrozen()](#tobefrozen)\n    - [.toBeSealed()](#tobesealed)\n  - [Promise](#promise)\n    - [.toResolve()](#toresolve)\n    - [.toReject()](#toreject)\n  - [String](#string)\n    - [.toBeString()](#tobestring)\n    - [.toBeHexadecimal(string)](#tobehexadecimal)\n    - [.toEqualCaseInsensitive(string)](#toequalcaseinsensitivestring)\n    - [.toStartWith(prefix)](#tostartwithprefix)\n    - [.toEndWith(suffix)](#toendwithsuffix)\n    - [.toInclude(substring)](#toincludesubstring)\n    - [.toIncludeRepeated(substring, times)](#toincluderepeatedsubstring-times)\n    - [.toIncludeMultiple([substring])](#toincludemultiplesubstring)\n- [LICENSE](#license)\n\n## Installation\n\nWith npm:\n```sh\nnpm install --save-dev jest-extended\n```\n\nWith yarn:\n```sh\nyarn add -D jest-extended\n```\n\n## Setup\n\n### Jest >v24\n\nAdd `jest-extended` to your Jest `setupFilesAfterEnv` configuration. [See for help](https://jestjs.io/docs/en/configuration.html#setupfilesafterenv-array)\n\n``` json\n\"jest\": {\n  \"setupFilesAfterEnv\": [\"jest-extended\"]\n}\n```\n\n### Jest <v23\n\n```json\n\"jest\": {\n  \"setupTestFrameworkScriptFile\": \"jest-extended\"\n}\n```\n\nIf you are already using another test framework, like [jest-chain](https://github.com/mattphillips/jest-chain), then you should create a test setup file and `require` each of the frameworks you are using.\n\nFor example:\n\n```js\n// ./testSetup.js\nrequire('jest-extended');\nrequire('jest-chain');\nrequire('any other test framework libraries you are using');\n```\n\nThen in your Jest config:\n\n```json\n\"jest\": {\n  \"setupTestFrameworkScriptFile\": \"./testSetup.js\"\n}\n```\n\n### Typescript\n\nIf your editor does not recognise the custom `jest-extended` matchers, add a `global.d.ts` file to your project with:\n\n```ts\nimport 'jest-extended';\n```\n\n## Asymmetric matchers\n\nAll matchers described in the API are also asymmetrical since [jest version 23](https://jestjs.io/blog/2018/05/29/jest-23-blazing-fast-delightful-testing#custom-asymmetric-matchers):\n\n```js\ntest('passes when using an asymmetrical matcher', () => {\n  expect([]).toEqual(expect.toBeArray());\n});\n```\n\n## API\n\n#### .pass(message)\n\n_Note: Currently unimplemented_\n\nPassing assertion.\n\n```js\nexpect().pass('should pass');\n```\n\n#### .fail(message)\n\n_Note: Currently unimplemented_\n\nFailing assertion.\n\n```js\nexpect().fail('test should fail');\n```\n\n#### .toBeEmpty()\n\nUse `.toBeEmpty` when checking if a `String` `''`, `Array` `[]`, `Object` `{}`, or `[Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Built-in_iterables)` is empty. Because `toBeEmpty` supports checking for emptiness of Iterables, you can use it to check whether a `Map`, or `Set` is empty, as well as checking that a generator yields no values.\n\n```js\ntest('passes when given an empty string', () => {\n  expect('').toBeEmpty();\n  expect('hello').not.toBeEmpty();\n});\n\ntest('passes when given an empty array', () => {\n  expect([]).toBeEmpty();\n  expect(['hello']).not.toBeEmpty();\n});\n\ntest('passes when given an empty object', () => {\n  expect({}).toBeEmpty();\n  expect({ hello: 'world' }).not.toBeEmpty();\n});\n```\n\n#### .toBeOneOf([members])\n\nUse `.toBeOneOf` when checking if a value is a member of a given `Array`.\n\n```js\ntest('passes when value is in given array', () => {\n  expect(1).toBeOneOf([1, 2, 3]);\n  expect(4).not.toBeOneOf([1, 2, 3]);\n});\n```\n\n#### .toBeNil()\n\nUse `.toBeNil` when checking a value is `null` or `undefined`.\n\n```js\ntest('passes when value is null or undefined', () => {\n  expect(null).toBeNil();\n  expect(undefined).toBeNil();\n  expect(true).not.toBeNil();\n});\n```\n\n#### .toSatisfy(predicate)\n\nUse `.toSatisfy` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean`.\n\n```js\ntest('passes when value passes given predicate', () => {\n  const greaterThanOneButNotThree = n => n > 1 && n !== 3;\n  expect(100).toSatisfy(greaterThanOneButNotThree);\n  expect(0).not.toSatisfy(greaterThanOneButNotThree);\n  expect(3).not.toSatisfy(greaterThanOneButNotThree);\n});\n```\n\n### Array\n\n#### .toBeArray()\n\nUse `.toBeArray` when checking if a value is an `Array`.\n\n```js\ntest('passes when value is an array', () => {\n  expect([]).toBeArray();\n  expect([1]).toBeArray();\n  expect(true).not.toBeArray();\n});\n```\n\n#### .toBeArrayOfSize()\n\nUse `.toBeArrayOfSize` when checking if a value is an `Array` of size x.\n\n```js\ntest('passes when value is an array', () => {\n  expect([]).toBeArrayOfSize(0);\n  expect([1]).toBeArrayOfSize(1);\n  expect(true).not.toBeArrayOfSize(1);\n});\n```\n\n#### .toIncludeAllMembers([members])\n\nUse `.toIncludeAllMembers` when checking if an `Array` contains all of the same members of a given set.\n\n```js\ntest('passes when given array values match the members of the set', () => {\n  expect([1, 2, 3]).toIncludeAllMembers([2, 1, 3]);\n  expect([1, 2, 2]).toIncludeAllMembers([2, 1]);\n});\n```\n\n#### .toIncludeAnyMembers([members])\n\nUse `.toIncludeAnyMembers` when checking if an `Array` contains any of the members of a given set.\n\n```js\ntest('passes when given array values match any of the members in the set', () => {\n  expect([1, 2, 3]).toIncludeAnyMembers([2, 1, 3]);\n  expect([1, 2, 2]).toIncludeAnyMembers([2]);\n  expect([1, 2, 2]).not.toIncludeAnyMembers([3]);\n});\n```\n\n#### .toIncludeSameMembers([members])\n\nUse `.toIncludeSameMembers` when checking if two arrays contain equal values, in any order.\n\n```js\ntest('passes when arrays match in a different order', () => {\n  expect([1, 2, 3]).toIncludeSameMembers([3, 1, 2]);\n  expect([{ foo: 'bar' }, { baz: 'qux' }]).toIncludeSameMembers([{ baz: 'qux' }, { foo: 'bar' }]);\n});\n```\n\n\n#### .toSatisfyAll(predicate)\n\nUse `.toSatisfyAll` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean` for all values in an array.\n\n```js\ntest('passes when all values in array pass given predicate', () => {\n  const isOdd = el => el % 2 === 1;\n  expect([1,3,5,7]).toSatisfyAll(isOdd);\n  expect([1,3,4,5,7]).not.toSatisfyAll(isOdd);\n});\n```\n\n### Boolean\n\n#### .toBeBoolean()\n\nUse `.toBeBoolean` when checking if a value is a `Boolean`.\n\n```js\ntest('passes when value is a boolean', () => {\n  expect(false).toBeBoolean();\n  expect(true).toBeBoolean();\n  expect(1 === 1).toBeBoolean();\n  expect(1).not.toBeBoolean();\n});\n```\n\n#### .toBeTrue()\n\nUse `.toBeTrue` when checking a value is equal (===) to `true`.\n\n```js\ntest('is jest cool', () => {\n  expect(isJestCool()).toBeTrue();\n  expect(false).not.toBeTrue();\n});\n```\n\n#### .toBeFalse()\n\nUse `.toBeFalse` when checking a value is equal (===) to `false`.\n\n```js\ntest('returns false', () => {\n  expect(areWeThereYet()).toBeFalse();\n  expect(true).not.toBeFalse();\n});\n```\n\n### ~~Date~~\n\nProposal in #117 (*under development*)\n\n### .toBeDate()\n\nUse `.toBeDate` when checking if a value is a `Date`.\n\n```js\ntest('passes when value is a date', () => {\n  expect(new Date()).toBeDate();\n  expect('01/01/2018').not.toBeDate();\n  expect(new Date('01/01/2018').toBeDate();\n  expect(undefined).not.toBeDate();\n});\n```\n\n### .toBeValidDate()\n\nUse `.toBeValidDate` when checking if a given `Date` object is valid.\n\n```js\ntest('passes when Date is valid', () => {\n  expect(new Date()).toBeValidDate();\n  expect('01/01/2018').not.toBeValidDate();\n  expect(new Date('01/01/2018').toBeValidDate();\n  expect(new Date('01/90/2018').not.toBeValidDate();\n  expect(undefined).not.toBeValidDate();\n});\n```\n\n### .toBeAfter(date)\n Use `.toBeAfter` when checking if a date occurs after `date`.\n ```js\ntest('passes when input is after date', () => {\n  expect(new Date('01/01/2019')).toBeAfter(new Date('01/01/2018'));\n  expect('01/01/2018').not.toBeAfter(new Date('01/01/2019'));\n});\n```\n ### .toBeBefore(date)\n Use `.toBeBefore` when checking if a date occurs before `date`.\n ```js\ntest('passes when input is before date', () => {\n  expect(new Date('01/01/2018')).toBeBefore(new Date('01/01/2019'));\n  expect('01/01/2019').not.toBeBefore(new Date('01/01/2018'));\n});\n```\n\n### Function\n\n#### .toBeFunction()\n\nUse `.toBeFunction` when checking if a value is a `Function`.\n\n```js\ntest('passes when value is a function', () => {\n  function noop = () {};\n  expect(() => {}).toBeFunction();\n  expect(function() {}).not.toBeFunction();\n  expect(noop).toBeFunction();\n  expect(true).not.toBeFunction();\n});\n```\n\n#### .toThrowWithMessage(type, message)\n\nUse `.toThrowWithMessage` when checking if a callback function throws an error with a given error type and given error message. Message can either be a `String` or a `RegExp`.\n\n```js\ntest('throws an error of type TypeError with message \"hello world\"', () => {\n  expect(() => {\n    throw TypeError(\"hello world\");\n  }).toThrowWithMessage(TypeError, \"hello world\");\n\n  expect(() => {\n    throw TypeError(\"hello world\");\n  }).toThrowWithMessage(TypeError, /hello world/);\n\n  expect(() => {\n    throw TypeError(\"hello world 2\");\n  }).not.toThrowWithMessage(TypeError, \"hello world\");\n\n  expect(() => {\n    throw TypeError(\"hello world 2\");\n  }).not.toThrowWithMessage(TypeError, /hello world/);\n});\n```\n\n### Mock\n\n#### .toHaveBeenCalledBefore()\n\nUse `.toHaveBeenCalledBefore` when checking if a `Mock` was called before another `Mock`.\n\n_Note: Required Jest version >=23_\n\n\n```js\n\nit('calls mock1 before mock2', () => {\n  const mock1 = jest.fn();\n  const mock2 = jest.fn();\n\n  mock1();\n  mock2();\n  mock1();\n\n  expect(mock1).toHaveBeenCalledBefore(mock2);\n});\n```\n\n#### .toHaveBeenCalledAfter()\n\nUse `.toHaveBeenCalledAfter` when checking if a `Mock` was called after another `Mock`.\n\n_Note: Required Jest version >=23_\n\n\n```js\n\nit('calls mock1 after mock2', () => {\n  const mock1 = jest.fn();\n  const mock2 = jest.fn();\n\n  mock2();\n  mock1();\n  mock2();\n\n  expect(mock1).toHaveBeenCalledAfter(mock2);\n});\n```\n\n### Number\n\n#### .toBeNumber()\n\nUse `.toBeNumber` when checking if a value is a `Number`.\n\n```js\ntest('passes when value is a number', () => {\n  expect(1).toBeNumber();\n  expect(NaN).toBeNumber();\n  expect(Infinity).toBeNumber();\n  expect(true).not.toBeNumber();\n});\n```\n\n#### .toBeNaN()\n\nUse `.toBeNaN` when checking a value is `NaN`.\n\n```js\ntest('passes when value is NaN', () => {\n  expect(NaN).toBeNaN();\n  expect(1).not.toBeNaN();\n});\n```\n\n#### .toBeFinite()\n\nUse `.toBeFinite` when checking if a value is a `Number`, not `NaN` or `Infinity`.\n\n```js\ntest('passes when value is a finite number', () => {\n  expect(1).toBeFinite();\n  expect(Infinity).not.toBeFinite();\n  expect(NaN).not.toBeFinite();\n});\n```\n\n#### .toBePositive()\n\nUse `.toBePositive` when checking if a value is a positive `Number`.\n\n```js\ntest('passes when value is a positive number', () => {\n  expect(1).toBePositive();\n  expect(Infinity).not.toBePositive();\n  expect(-1).not.toBePositive();\n  expect(NaN).not.toBePositive();\n});\n```\n\n#### .toBeNegative()\n\nUse `.toBeNegative` when checking if a value is a negative `Number`.\n\n```js\ntest('passes when value is a negative number', () => {\n  expect(-1).toBeNegative();\n  expect(-Infinity).not.toBeNegative();\n  expect(1).not.toBeNegative();\n  expect(NaN).not.toBeNegative();\n});\n```\n\n#### .toBeEven()\n\n\nUse `.toBeEven` when checking if a value is an even `Number`.\n\n```js\ntest('passes when value is an even number', () => {\n  expect(2).toBeEven();\n  expect(1).not.toBeEven();\n  expect(NaN).not.toBeEven();\n});\n```\n\n#### .toBeOdd()\n\nUse `.toBeOdd` when checking if a value is an odd `Number`.\n\n```js\ntest('passes when value is an odd number', () => {\n  expect(1).toBeOdd();\n  expect(2).not.toBeOdd();\n  expect(NaN).not.toBeOdd();\n});\n```\n\n#### .toBeWithin(start, end)\n\nUse `.toBeWithin` when checking if a number is in between the given bounds of: start (inclusive) and end (exclusive).\n\n```js\ntest('passes when number is within given bounds', () => {\n  expect(1).toBeWithin(1, 3);\n  expect(2).toBeWithin(1, 3);\n  expect(3).not.toBeWithin(1, 3);\n});\n```\n\n### Object\n\n#### .toBeObject()\n\nUse `.toBeObject` when checking if a value is an `Object`.\n\n```js\ntest('passes when value is an object', () => {\n  expect({}).toBeObject();\n  expect({ a: 'hello' }).toBeObject();\n  expect(true).not.toBeObject();\n});\n```\n\n#### .toContainKey(key)\n\nUse `.toContainKey` when checking if an object contains the provided key.\n\n```js\ntest('passes when object contains the given key', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainKey('a');\n  expect(o).toContainKey('b');\n  expect(o).toContainKey('c');\n  expect(o).not.toContainKey('d');\n});\n```\n\n#### .toContainKeys([keys])\n\nUse `.toContainKeys` when checking if an object has all of the provided keys.\n\n```js\ntest('passes when object contains all keys', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainKeys(['a', 'b']);\n  expect(o).toContainKeys(['b', 'c']);\n  expect(o).not.toContainKeys(['d']);\n});\n```\n\n#### .toContainAllKeys([keys])\n\nUse `.toContainAllKeys` when checking if an object only contains all of the provided keys.\n\n```js\ntest('passes when object only contains all keys', () => {\n  const o = { a: 'hello', b: 'world' };\n  expect(o).toContainAllKeys(['a', 'b']);\n  expect(o).toContainAllKeys(['b', 'a']);\n  expect(o).not.toContainAllKeys(['b']);\n});\n```\n\n#### .toContainAnyKeys([keys])\n\nUse `.toContainAnyKeys` when checking if an object contains at least one of the provided keys.\n\n```js\ntest('passes when object contains at least one matching key', () => {\n  const o = { a: 'hello', b: 'world' };\n  expect(o).toContainAnyKeys(['a']);\n  expect(o).toContainAnyKeys(['b']);\n  expect(o).toContainAnyKeys(['b', 'c']);\n  expect(o).not.toContainAnyKeys(['c']);\n});\n```\n\n#### .toContainValue(value)\n\nUse `.toContainValue` when checking if an object contains the provided value.\n\n```js\ntest('passes when object contains given value', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainValue('foo');\n  expect(o).toContainValue('bar');\n  expect(o).not.toContainValue('qux');\n});\n```\n\n#### .toContainValues([values])\n\nUse `.toContainValues` when checking if an object contains all of the provided values.\n\n```js\ntest('passes when object contains all of the given values', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainValues(['foo']);\n  expect(o).toContainValues(['baz', 'bar']);\n  expect(o).not.toContainValues(['qux', 'foo']);\n});\n```\n\n#### .toContainAllValues([values])\n\nUse `.toContainAllValues` when checking if an object only contains all of the provided values.\n\n```js\ntest('passes when object only contains all of the given values', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainAllValues(['foo', 'bar', 'baz']);\n  expect(o).toContainAllValues(['baz', 'bar', 'foo']);\n  expect(o).not.toContainAllValues(['bar', 'foo']);\n});\n```\n\n#### .toContainAnyValues([values])\n\nUse `.toContainAnyValues` when checking if an object contains at least one of the provided values.\n\n```js\ntest('passes when object contains at least one of the given values', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainAnyValues(['qux', 'foo']);\n  expect(o).toContainAnyValues(['qux', 'bar']);\n  expect(o).toContainAnyValues(['qux', 'baz']);\n  expect(o).not.toContainAnyValues(['qux']);\n});\n```\n\n#### .toContainEntry([key, value])\n\nUse `.toContainEntry` when checking if an object contains the provided entry.\n\n```js\ntest('passes when object contains given entry', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainEntry(['a', 'foo']);\n  expect(o).toContainEntry(['b', 'bar']);\n  expect(o).toContainEntry(['c', 'baz']);\n  expect(o).not.toContainEntry(['a', 'qux']);\n});\n```\n\n#### .toContainEntries([[key, value]])\n\nUse `.toContainEntries` when checking if an object contains all of the provided entries.\n\n```js\ntest('passes when object contains all of the given entries', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainEntries([['a', 'foo']]);\n  expect(o).toContainEntries([['c', 'baz'], ['a', 'foo']]);\n  expect(o).not.toContainEntries([['b', 'qux'], ['a', 'foo']]);\n});\n```\n\n#### .toContainAllEntries([[key, value]])\n\nUse `.toContainAllEntries` when checking if an object only contains all of the provided entries.\n\n```js\ntest('passes when object only contains all of the given entries', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainAllEntries([['a', 'foo'], ['b', 'bar'], ['c', 'baz']]);\n  expect(o).not.toContainAllEntries([['a', 'foo'], ['b', 'bar']]);\n});\n```\n\n#### .toContainAnyEntries([[key, value]])\n\nUse `.toContainAnyEntries` when checking if an object contains at least one of the provided entries.\n\n```js\ntest('passes when object contains at least one of the given entries', () => {\n  const o = { a: 'foo', b: 'bar', c: 'baz' };\n  expect(o).toContainAnyEntries([['a', 'qux'], ['a', 'foo']]);\n  expect(o).toContainAnyEntries([['a', 'qux'], ['b', 'bar']]);\n  expect(o).toContainAnyEntries([['a', 'qux'], ['c', 'baz']]);\n  expect(o).not.toContainAnyEntries([['d', 'qux']]);\n});\n```\n\n#### .toBeExtensible()\n\nUse `.toBeExtensible` when checking if an object is extensible.\n\n```js\ntest('passes when value is extensible', () => {\n  expect({a: 1}).toBeExtensible();\n  expect(1).not.toBeExtensible();\n});\n```\n\n#### .toBeFrozen()\n\nUse `.toBeFrozen` when checking if an object is frozen.\n\n```js\ntest('passes when value is frozen', () => {\n  expect(Object.frozen({})).toBeFrozen();\n  expect({}).not.toBeFrozen();\n  expect(1).not.toBeFrozen();\n});\n```\n\n#### .toBeSealed()\n\nUse `.toBeSealed` when checking if an object is sealed.\n\n```js\ntest('passes when value is sealed', () => {\n  expect(Object.seal({})).toBeSealed();\n  expect({}).not.toBeSealed();\n  expect(1).not.toBeSealed();\n});\n```\n\n### Promise\n\n#### .toResolve()\n\nUse `.toResolve` when checking if a promise is resolved.\n\n```js\ntest('passes when a promise resolves', async () => {\n  await expect(Promise.resolve()).toResolve();\n});\n```\n\n#### .toReject()\n\nUse `.toReject` when checking if a promise is rejected.\n\n```js\ntest('passes when a promise rejects', async () => {\n  await expect(Promise.reject()).toReject();\n});\n```\n\n### String\n\n#### .toBeString()\n\nUse `.toBeString` when checking if a value is a `String`.\n\n```js\ntest('passes when value is a string', () => {\n  expect('').toBeString();\n  expect('hello').toBeString();\n  expect(new String('hello')).toBeString();\n  expect(true).not.toBeString();\n});\n```\n\n#### .toBeHexadecimal(string)\n\nUse `.toBeHexadecimal` when checking if a value is a valid HTML hexadecimal color.\n\n```js\ntest('passes when value is a valid hexadecimal', () => {\n  expect('#abc123').toBeHexadecimal();\n  expect('#FFF').toBeHexadecimal();\n  expect('#000000').toBeHexadecimal();\n  expect('#123ffg').not.toBeHexadecimal();\n});\n```\n\n#### .toEqualCaseInsensitive(string)\n\nUse `.toEqualCaseInsensitive` when checking if a string is equal (===) to another ignoring the casing of both strings.\n\n```js\ntest('passes when strings are equal ignoring case', () => {\n  expect('hello world').toEqualCaseInsensitive('hello world');\n  expect('hello WORLD').toEqualCaseInsensitive('HELLO world');\n  expect('HELLO WORLD').toEqualCaseInsensitive('hello world');\n  expect('hello world').toEqualCaseInsensitive('HELLO WORLD');\n  expect('hello world').not.toEqualCaseInsensitive('hello');\n});\n```\n\n#### .toStartWith(prefix)\n\nUse `.toStartWith` when checking if a `String` starts with a given `String` prefix.\n\n```js\ntest('passes when value is starts with given string', () => {\n  expect('hello world').toStartWith('hello');\n  expect('hello world').not.toStartWith('world');\n});\n```\n\n#### .toEndWith(suffix)\n\nUse `.toEndWith` when checking if a `String` ends with a given `String` suffix.\n\n```js\ntest('passes when value is ends with given string', () => {\n  expect('hello world').toEndWith('world');\n  expect('hello world').not.toEndWith('hello');\n});\n```\n\n#### .toInclude(substring)\n\nUse `.toInclude` when checking if a `String` includes the given `String` substring.\n\n```js\ntest('passes when value includes substring', () => {\n  expect('hello world').toInclude('ell');\n  expect('hello world').not.toInclude('bob');\n});\n```\n\n#### .toIncludeRepeated(substring, times)\n\nUse `.toIncludeRepeated` when checking if a `String` includes the given `String` substring the correct number of times.\n\n```js\ntest('passes when value includes substring n times', () => {\n  expect('hello hello world').toIncludeRepeated('hello', 2);\n  expect('hello hello world').not.toIncludeRepeated('hello', 1);\n});\n```\n\n#### .toIncludeMultiple([substring])\n\nUse `.toIncludeMultiple` when checking if a `String` includes all of the given substrings.\n\n```js\ntest('passes when value includes all substrings', () => {\n  expect('hello world').toIncludeMultiple(['world', 'hello']);\n  expect('hello world').not.toIncludeMultiple(['world', 'hello', 'bob']);\n});\n```\n\n## LICENSE\n\n[MIT](/LICENSE)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017-present Matt Phillips <matt@mattphillips.io> (mattphillips.io)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jest-extended/-/jest-extended-0.11.5.tgz#f063b3f1eaadad8d7c13a01f0dfe0f538d498ccf",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jest-extended/-/jest-extended-0.11.5.tgz",
    "hash": "f063b3f1eaadad8d7c13a01f0dfe0f538d498ccf",
    "integrity": "sha512-3RsdFpLWKScpsLD6hJuyr/tV5iFOrw7v6YjA3tPdda9sJwoHwcMROws5gwiIZfcwhHlJRwFJB2OUvGmF3evV/Q==",
    "registry": "npm",
    "packageName": "jest-extended",
    "cacheIntegrity": "sha512-3RsdFpLWKScpsLD6hJuyr/tV5iFOrw7v6YjA3tPdda9sJwoHwcMROws5gwiIZfcwhHlJRwFJB2OUvGmF3evV/Q== sha1-8GOz8eqtrY18E6AfDf4PU41JjM8="
  },
  "registry": "npm",
  "hash": "f063b3f1eaadad8d7c13a01f0dfe0f538d498ccf"
}