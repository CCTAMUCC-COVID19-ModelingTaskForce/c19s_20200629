{
  "manifest": {
    "name": "utility-types",
    "version": "3.10.0",
    "description": "Utility Types Collection for TypeScript",
    "author": {
      "name": "Piotr Witek",
      "email": "piotrek.witek@gmail.com",
      "url": "http://piotrwitek.github.io"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/piotrwitek/utility-types"
    },
    "homepage": "https://github.com/piotrwitek/utility-types",
    "license": "MIT",
    "types": "dist/index.d.ts",
    "main": "dist/index.js",
    "engines": {
      "node": ">= 4"
    },
    "husky": {
      "hooks": {
        "pre-push": "npm run prettier:fix && npm run lint && npm run tsc && npm run test:update"
      }
    },
    "scripts": {
      "ci-check": "npm run prettier && npm run lint && npm run tsc && npm run test",
      "reinstall": "rm -rf node_modules/ dist/ && npm install",
      "prettier": "prettier --list-different 'src/**/*.ts' || (echo '\nPlease fix code formatting by running:\nnpm run prettier:fix\n'; exit 1)",
      "prettier:fix": "prettier --write src/**/*.ts",
      "lint": "tslint --project ./tsconfig.json",
      "tsc": "tsc -p . --noEmit",
      "tsc:watch": "tsc -p . --noEmit -w",
      "test": "jest --config jest.config.json && dts-jest-remap ./src/*.spec.ts --rename {{basename}}.snap.{{extname}} --check",
      "test:update": "jest --config jest.config.json --no-cache -u && dts-jest-remap ./src/*.spec.ts --rename {{basename}}.snap.{{extname}}",
      "test:watch": "jest --config jest.config.json --watch",
      "prebuild": "rm -rf dist/",
      "build": "tsc -p ./tsconfig.build.json --outDir dist/",
      "prepublishOnly": "npm run reinstall && npm run ci-check && npm run build"
    },
    "dependencies": {},
    "devDependencies": {
      "@types/jest": "24.0.22",
      "dts-jest": "23.0.0",
      "husky": "3.0.9",
      "jest": "24.9.0",
      "prettier": "1.19.0",
      "ts-jest": "24.1.0",
      "tslint": "5.20.1",
      "typescript": "3.7.2"
    },
    "keywords": [
      "typescript",
      "utility",
      "types",
      "static-typing",
      "mapped-types",
      "flow",
      "flow-typed"
    ],
    "_registry": "npm",
    "_loc": "/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/.cache/yarn/v6/npm-utility-types-3.10.0-ea4148f9a741015f05ed74fd615e1d20e6bed82b-integrity/node_modules/utility-types/package.json",
    "readmeFilename": "README.md",
    "readme": "<div align=\"center\">\n\n# utility-types\n\nCollection of utility types, complementing TypeScript built-in mapped types and aliases (think \"lodash\" for static types).\n\n[![Latest Stable Version](https://img.shields.io/npm/v/utility-types.svg)](https://www.npmjs.com/package/utility-types)\n[![NPM Downloads](https://img.shields.io/npm/dm/utility-types.svg)](https://www.npmjs.com/package/utility-types)\n[![NPM Downloads](https://img.shields.io/npm/dt/utility-types.svg)](https://www.npmjs.com/package/utility-types)\n[![Bundlephobia Size](https://img.shields.io/bundlephobia/minzip/utility-types.svg)](https://www.npmjs.com/package/utility-types)\n\n[![Build Status](https://semaphoreci.com/api/v1/piotrekwitek/utility-types/branches/master/shields_badge.svg)](https://semaphoreci.com/piotrekwitek/utility-types)\n[![Dependency Status](https://img.shields.io/david/piotrwitek/utility-types.svg)](https://david-dm.org/piotrwitek/utility-types)\n[![License](https://img.shields.io/npm/l/utility-types.svg?style=flat)](https://david-dm.org/piotrwitek/utility-types?type=peer)\n[![Join the community on Spectrum](https://withspectrum.github.io/badge/badge.svg)](https://spectrum.chat/utility-types)\n\n_Found it useful? Want more updates?_\n\n[**Show your support by giving a :star:**](https://github.com/piotrwitek/utility-types/stargazers)\n\n<a href=\"https://www.buymeacoffee.com/piotrekwitek\">\n  <img src=\"https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png\" alt=\"Buy Me a Coffee\">\n</a>\n<a href=\"https://www.patreon.com/piotrekwitek\">\n  <img src=\"https://c5.patreon.com/external/logo/become_a_patron_button@2x.png\" alt=\"Become a Patron\" width=\"160\">\n</a>\n\n<br/><hr/>\n\n### **What's new?**\n\n:tada: _Now updated to support **TypeScript v3.7**_ :tada:\n\n<hr/><br/>\n\n</div>\n\n## Features\n\n* Providing a set of [Common Types](#table-of-contents) for TypeScript projects that are idiomatic and complementary to existing [TypeScript Mapped Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) so you don't need to copy them between the projects.\n* Providing a set of [Additional Types](#) compatible with [Flow's Utility Types](https://flow.org/en/docs/types/utilities/) to allow much easier migration to `TypeScript`.\n\n## Goals\n\n* Quality - thoroughly tested for type correctness with type-testing library `dts-jest`\n* Secure and minimal - no third-party dependencies\n* No runtime cost - it's type-level only\n\n## Installation\n\n```bash\n# NPM\nnpm install utility-types\n\n# YARN\nyarn add utility-types\n```\n\n## Compatibility Notes\n\n**TypeScript support**\n* `v3.x.x` - TypeScript v3.1+\n* `v2.x.x` - TypeScript v2.8.1+\n* `v1.x.x` - TypeScript v2.7.2+\n\n## Funding Issues\n**Utility-Types** is an open-source project created by people investing their time for the benefit of our community.\n\nIssues like bug fixes or feature requests can be very quickly resolved when funded through the IssueHunt platform.\n\nI highly recommend adding a bounty to the issue that you're waiting for to attract some contributors willing to work on it.\n\n[![Let's fund issues in this repository](https://issuehunt.io/static/embed/issuehunt-button-v1.svg)](https://issuehunt.io/repos/76400842)\n\n## Contributing\n\nWe are open for contributions. If you're planning to contribute please make sure to read the contributing guide as it can save you from wasting your time: [CONTRIBUTING.md](/CONTRIBUTING.md)\n\n---\n\n* _(built-in)_ - types built-in TypeScript, no need to import\n\n# Table of Contents\n\n## Aliases & Type Guards\n\n* [`Primitive`](#primitive)\n* [`isPrimitive`](#isprimitive)\n* [`Falsy`](#falsy)\n* [`isFalsy`](#isfalsy)\n\n## Union operators\n\n* [`SetIntersection<A, B>`](#setintersectiona-b-same-as-extract)\n* [`SetDifference<A, B>`](#setdifferencea-b-same-as-exclude)\n* [`SetComplement<A, A1>`](#setcomplementa-a1)\n* [`SymmetricDifference<A, B>`](#symmetricdifferencea-b)\n* [`Exclude<A, B>`](#excludea-b) _(built-in)_\n* [`Extract<A, B>`](#extracta-b) _(built-in)_\n* [`NonNullable<T>`](#nonnullablea) _(built-in)_\n* [`NonUndefined<T>`](#nonundefineda)\n\n## Object operators\n\n* [`FunctionKeys<T>`](#functionkeyst)\n* [`NonFunctionKeys<T>`](#nonfunctionkeyst)\n* [`MutableKeys<T>`](#mutablekeyst)\n* [`ReadonlyKeys<T>`](#readonlykeyst)\n* [`RequiredKeys<T>`](#requiredkeyst)\n* [`OptionalKeys<T>`](#optionalkeyst)\n* [`Optional<T, K>`](#optionalt-k)\n* [`Partial<T>`](#partialt) _(built-in)_\n* [`DeepPartial<T>`](#deeppartialt)\n* [`Required<T, K>`](#requiredt-k)\n* [`DeepRequired<T>`](#deeprequiredt)\n* [`Readonly<T>`](#readonlyt) _(built-in)_\n* [`DeepReadonly<T>`](#deepreadonlyt)\n* [`Mutable<T>`](#mutablet)\n* [`Pick<T, K>` _(built-in)_](#pickt-k-built-in)\n* [`Omit<T, K>`](#omitt-k) _(built-in)_\n* [`PickByValue<T, ValueType>`](#pickbyvaluet-valuetype)\n* [`PickByValueExact<T, ValueType>`](#pickbyvalueexactt-valuetype)\n* [`OmitByValue<T, ValueType>`](#omitbyvaluet-valuetype)\n* [`OmitByValueExact<T, ValueType>`](#omitbyvalueexactt-valuetype)\n* [`Intersection<T, U>`](#intersectiont-u)\n* [`Diff<T, U>`](#difft-u)\n* [`Subtract<T, T1>`](#subtractt-t1)\n* [`Overwrite<T, U>`](#overwritet-u)\n* [`Assign<T, U>`](#assignt-u)\n* [`ValuesType<T>`](#valuestypet)\n\n## Special operators\n\n* [`ReturnType<T>`](#returntypet) _(built-in)_\n* [`InstanceType<T>`](#instancetypet) _(built-in)_\n* [`PromiseType<T>`](#promisetypet)\n* [`Unionize<T>`](#unionizet)\n* [`Brand<T, U>`](#brandt-u)\n* [`UnionToIntersection<U>`](#uniontointersectionu)\n\n## Flow's Utility Types\n\n* [`$Keys<T>`](#keyst)\n* [`$Values<T>`](#valuest)\n* [`$ReadOnly<T>`](#readonly2)\n* [`$Diff<T, U>`](#diff2)\n* [`$PropertyType<T, K>`](#propertytypet-k)\n* [`$ElementType<T, K>`](#elementtypet-k)\n* [`$Call<T>`](#callt)\n* [`$Shape<T>`](#shapet)\n* [`$NonMaybeType<T>`](#nonmaybetypet)\n* [`Class<T>`](#classt)\n* [`mixed`](#mixed)\n\n## Deprecated API (use at own risk)\n* `getReturnOfExpression()` - from TS v2.0 it's better to use type-level `ReturnType` instead\n\n---\n\n### `Primitive`\n\nType representing primitive types in JavaScript, and thus TypeScript: `string | number | bigint | boolean |  symbol | null | undefined`\n\nYou can test for singular of these types with [`typeof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)\n\n### `isPrimitive`\n\nThis is a [TypeScript Typeguard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types) for the [`Primitive`](#primitive) type.\n\nThis can be useful to control the type of a parameter as the program flows. Example:\n\n```ts\nconst consumer = (param: Primitive[] | Primitive): string => {\n    if (isPrimitive(param)) {\n        // typeof param === Primitive\n        return String(param) + ' was Primitive';\n    }\n    // typeof param === Primitive[]\n    const resultArray = param\n        .map(consumer)\n        .map(rootString => '\\n\\t' + rootString);\n    return resultArray.reduce((comm, newV) => comm + newV, 'this was nested:');\n};\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Falsy`\n\nType representing falsy values in TypeScript: `false | \"\" | 0 | null | undefined`\n> Except `NaN` which cannot be represented as a type literal\n\n### `isFalsy`\n\n```ts\nconst consumer = (param: Falsy | string): string => {\n    if (isFalsy(param)) {\n        // typeof param === Falsy\n        return String(param) + ' was Falsy';\n    }\n    // typeof param === string\n    return param.toString();\n};\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `SetIntersection<A, B>` (same as Extract)\n\nSet intersection of given union types `A` and `B`\n\n**Usage:**\n\n```ts\nimport { SetIntersection } from 'utility-types';\n\n// Expect: \"2\" | \"3\"\ntype ResultSet = SetIntersection<'1' | '2' | '3', '2' | '3' | '4'>;\n// Expect: () => void\ntype ResultSetMixed = SetIntersection<string | number | (() => void), Function>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `SetDifference<A, B>` (same as Exclude)\n\nSet difference of given union types `A` and `B`\n\n**Usage:**\n\n```ts\nimport { SetDifference } from 'utility-types';\n\n// Expect: \"1\"\ntype ResultSet = SetDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n// Expect: string | number\ntype ResultSetMixed = SetDifference<string | number | (() => void), Function>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `SetComplement<A, A1>`\n\nSet complement of given union types `A` and (it's subset) `A1`\n\n**Usage:**\n\n```ts\nimport { SetComplement } from 'utility-types';\n\n// Expect: \"1\"\ntype ResultSet = SetComplement<'1' | '2' | '3', '2' | '3'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `SymmetricDifference<A, B>`\n\nSet difference of union and intersection of given union types `A` and `B`\n\n**Usage:**\n\n```ts\nimport { SymmetricDifference } from 'utility-types';\n\n// Expect: \"1\" | \"4\"\ntype ResultSet = SymmetricDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `NonNullable<A>`\n\nExclude `null` and `undefined` from set `A`\n\n[⇧ back to top](#table-of-contents)\n\n### `NonUndefined<A>`\n\nExclude `undefined` from set `A`\n\n[⇧ back to top](#table-of-contents)\n\n### `Exclude<A, B>`\n\nExclude subset `B` from set `A`\n\n[⇧ back to top](#table-of-contents)\n\n### `Extract<A, B>`\n\nExtract subset `B` from set `A`\n\n[⇧ back to top](#table-of-contents)\n\n## Operations on objects\n\n### `FunctionKeys<T>`\n\nGet union type of keys that are functions in object type `T`\n\n**Usage:**\n\n```ts\nimport { FunctionKeys } from 'utility-types';\n\ntype MixedProps = { name: string; setName: (name: string) => void };\n\n// Expect: \"setName\"\ntype Keys = FunctionKeys<MixedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `NonFunctionKeys<T>`\n\nGet union type of keys that are non-functions in object type `T`\n\n**Usage:**\n\n```ts\nimport { NonFunctionKeys } from 'utility-types';\n\ntype MixedProps = { name: string; setName: (name: string) => void };\n\n// Expect: \"name\"\ntype Keys = NonFunctionKeys<MixedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `MutableKeys<T>`\n\nGet union type of keys that are mutable (not readonly) in object type `T`\n\nAlias: `WritableKeys<T>`\n\n**Usage:**\n\n```ts\nimport { MutableKeys } from 'utility-types';\n\ntype Props = { readonly foo: string; bar: number };\n\n// Expect: \"bar\"\ntype Keys = MutableKeys<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `ReadonlyKeys<T>`\n\nGet union type of keys that are readonly in object type `T`\n\n**Usage:**\n\n```ts\nimport { ReadonlyKeys } from 'utility-types';\n\ntype Props = { readonly foo: string; bar: number };\n\n// Expect: \"foo\"\ntype Keys = ReadonlyKeys<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `RequiredKeys<T>`\n\nGet union type of keys that are required in object type `T`\n\n**Usage:**\n\n```ts\nimport { RequiredKeys } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n\n// Expect: \"req\" | \"reqUndef\"\ntype Keys = RequiredKeys<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `OptionalKeys<T>`\n\nGet union type of keys that are optional in object type `T`\n\n**Usage:**\n\n```ts\nimport { OptionalKeys } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n\n// Expect: \"opt\" | \"optUndef\"\ntype Keys = OptionalKeys<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Optional<T, K>`\n\nFrom `T` make a set of properties by key `K` become optional\n\n**Usage:**\n\n```ts\nimport { Optional } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean; };\n\n// Expect: { name?: string; age?: number; visible?: boolean; }\ntype Props = Optional<Props>\n// Expect: { name: string; age?: number; visible?: boolean; }\ntype Props = Optional<Props, 'age' | 'visible'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n\n### `Pick<T, K>` _(built-in)_\n\nFrom `T` pick a set of properties by key `K`\n\n**Usage:**\n\n```ts\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: { age: number; }\ntype Props = Pick<Props, 'age'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `PickByValue<T, ValueType>`\n\nFrom `T` pick a set of properties by value matching `ValueType`.\n_(Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c))_\n\n**Usage:**\n\n```ts\nimport { PickByValue } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; };\n\n// Expect: { req: number }\ntype Props = PickByValue<Props, number>;\n// Expect: { req: number; reqUndef: number | undefined; }\ntype Props = PickByValue<Props, number | undefined>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `PickByValueExact<T, ValueType>`\n\nFrom `T` pick a set of properties by value matching exact `ValueType`.\n\n**Usage:**\n\n```ts\nimport { PickByValueExact } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; };\n\n// Expect: { req: number }\ntype Props = PickByValueExact<Props, number>;\n// Expect: { reqUndef: number | undefined; }\ntype Props = PickByValueExact<Props, number | undefined>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Omit<T, K>`\n\nFrom `T` remove a set of properties by key `K`\n\n**Usage:**\n\n```ts\nimport { Omit } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: { name: string; visible: boolean; }\ntype Props = Omit<Props, 'age'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `OmitByValue<T, ValueType>`\n\nFrom `T` remove a set of properties by value matching `ValueType`.\n_(Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c))_\n\n**Usage:**\n\n```ts\nimport { OmitByValue } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; };\n\n// Expect: { reqUndef: number | undefined; opt?: string; }\ntype Props = OmitByValue<Props, number>;\n// Expect: { opt?: string; }\ntype Props = OmitByValue<Props, number | undefined>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `OmitByValueExact<T, ValueType>`\n\nFrom `T` remove a set of properties by value matching exact `ValueType`.\n\n**Usage:**\n\n```ts\nimport { OmitByValueExact } from 'utility-types';\n\ntype Props = { req: number; reqUndef: number | undefined; opt?: string; };\n\n// Expect: { reqUndef: number | undefined; opt?: string; }\ntype Props = OmitByValueExact<Props, number>;\n// Expect: { req: number; opt?: string }\ntype Props = OmitByValueExact<Props, number | undefined>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Intersection<T, U>`\n\nFrom `T` pick properties that exist in `U`\n\n**Usage:**\n\n```ts\nimport { Intersection } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype DefaultProps = { age: number };\n\n// Expect: { age: number; }\ntype DuplicatedProps = Intersection<Props, DefaultProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Diff<T, U>`\n\nFrom `T` remove properties that exist in `U`\n\n**Usage:**\n\n```ts\nimport { Diff } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype DefaultProps = { age: number };\n\n// Expect: { name: string; visible: boolean; }\ntype RequiredProps = Diff<Props, DefaultProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Subtract<T, T1>`\n\nFrom `T` remove properties that exist in `T1` (`T1` has a subset of the properties of `T`)\n\n**Usage:**\n\n```ts\nimport { Subtract } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype DefaultProps = { age: number };\n\n// Expect: { name: string; visible: boolean; }\ntype RequiredProps = Subtract<Props, DefaultProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Overwrite<T, U>`\n\nFrom `U` overwrite properties to `T`\n\n**Usage:**\n\n```ts\nimport { Overwrite } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype NewProps = { age: string; other: string };\n\n// Expect: { name: string; age: string; visible: boolean; }\ntype ReplacedProps = Overwrite<Props, NewProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Assign<T, U>`\n\nFrom `U` assign properties to `T` (just like object assign)\n\n**Usage:**\n\n```ts\nimport { Assign } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype NewProps = { age: string; other: string };\n\n// Expect: { name: string; age: number; visible: boolean; other: string; }\ntype ExtendedProps = Assign<Props, NewProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `ValuesType<T>`\n\nGet the union type of all the values in an object, tuple, array or array-like type `T`.\n\n**Usage:**\n\n```ts\nimport { ValuesType } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n// Expect: string | number | boolean\ntype PropsValues = ValuesType<Props>;\n\ntype NumberArray = number[];\n// Expect: number\ntype NumberItems = ValuesType<NumberArray>;\n\ntype ReadonlyNumberTuple = readonly [1, 2];\n// Expect: 1 | 2\ntype AnotherNumberUnion = ValuesType<NumberTuple>;\n\ntype BinaryArray = Uint8Array;\n// Expect: number\ntype BinaryItems = ValuesType<BinaryArray>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Partial<T>`\n\nMake all properties of object type optional\n\n[⇧ back to top](#table-of-contents)\n\n### `Required<T, K>`\n\nFrom `T` make a set of properties by key `K` become required\n\n**Usage:**\n\n```ts\nimport { Required } from 'utility-types';\n\ntype Props = { name?: string; age?: number; visible?: boolean; };\n\n// Expect: { name: string; age: number; visible: boolean; }\ntype Props = Required<Props>\n// Expect: { name?: string; age: number; visible: boolean; }\ntype Props = Required<Props, 'age' | 'visible'>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Readonly<T>`\n\nMake all properties of object type readonly\n\n[⇧ back to top](#table-of-contents)\n\n### `Mutable<T>`\n\nFrom `T` make all properties become mutable\n\nAlias: `Writable<T>`\n\n```ts\nimport { Mutable } from 'utility-types';\n\ntype Props = {\n  readonly name: string;\n  readonly age: number;\n  readonly visible: boolean;\n};\n\n// Expect: { name: string; age: number; visible: boolean; }\nMutable<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `ReturnType<T>`\n\nObtain the return type of a function\n\n[⇧ back to top](#table-of-contents)\n\n### `InstanceType<T>`\n\nObtain the instance type of a class\n\n[⇧ back to top](#table-of-contents)\n\n### `Unionize<T>`\n\nDisjoin object to form union of objects, each with single property\n\n**Usage:**\n\n```ts\nimport { Unionize } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: { name: string; } | { age: number; } | { visible: boolean; }\ntype UnionizedType = Unionize<Props>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `PromiseType<T>`\n\nObtain Promise resolve type\n\n**Usage:**\n\n```ts\nimport { PromiseType } from 'utility-types';\n\n// Expect: string\ntype Response = PromiseType<Promise<string>>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `DeepReadonly<T>`\n\nReadonly that works for deeply nested structures\n\n**Usage:**\n\n```ts\nimport { DeepReadonly } from 'utility-types';\n\ntype NestedProps = {\n  first: {\n    second: {\n      name: string;\n    };\n  };\n};\n\n// Expect: {\n//   readonly first: {\n//     readonly second: {\n//       readonly name: string;\n//     };\n//   };\n// }\ntype ReadonlyNestedProps = DeepReadonly<NestedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `DeepRequired<T>`\n\nRequired that works for deeply nested structures\n\n**Usage:**\n\n```ts\nimport { DeepRequired } from 'utility-types';\n\ntype NestedProps = {\n  first?: {\n    second?: {\n      name?: string;\n    };\n  };\n};\n\n// Expect: {\n//   first: {\n//     second: {\n//       name: string;\n//     };\n//   };\n// }\ntype RequiredNestedProps = DeepRequired<NestedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `DeepNonNullable<T>`\n\nNonNullable that works for deeply nested structure\n\n**Usage:**\n\n```ts\nimport { DeepNonNullable } from 'utility-types';\n\ntype NestedProps = {\n  first?: null | {\n    second?: null | {\n      name?: string | null | undefined;\n    };\n  };\n};\n\n// Expect: {\n//   first: {\n//     second: {\n//       name: string;\n//     };\n//   };\n// }\ntype RequiredNestedProps = DeepNonNullable<NestedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `DeepPartial<T>`\n\nPartial that works for deeply nested structures\n\n**Usage:**\n\n```ts\nimport { DeepPartial } from 'utility-types';\n\ntype NestedProps = {\n  first: {\n    second: {\n      name: string;\n    };\n  };\n};\n\n// Expect: {\n//   first?: {\n//     second?: {\n//       name?: string;\n//     };\n//   };\n// }\ntype PartialNestedProps = DeepPartial<NestedProps>;\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `Brand<T, U>`\n\nDefine nominal type of `U` based on type of `T`. Similar to Opaque types in Flow.\n\n**Usage:**\n\n```ts\nimport { Brand } from 'utility-types';\n\ntype USD = Brand<number, \"USD\">\ntype EUR = Brand<number, \"EUR\">\n\nconst tax = 5 as USD;\nconst usd = 10 as USD;\nconst eur = 10 as EUR;\n\nfunction gross(net: USD): USD {\n  return (net + tax) as USD;\n}\n\ngross(usd); // ok\ngross(eur); // Type '\"EUR\"' is not assignable to type '\"USD\"'.\n```\n\n[⇧ back to top](#table-of-contents)\n\n### `UnionToIntersection<U>`\n\nGet intersection type given union type `U`\n\n**Usage:**\n\n```ts\nimport { UnionToIntersection } from 'utility-types';\n\n// Expect: { name: string } & { age: number } & { visible: boolean }\nUnionToIntersection<{ name: string } | { age: number } | { visible: boolean }>\n```\n\n[⇧ back to top](#table-of-contents)\n\n---\n\n## Flow's Utility Types\n\n### `$Keys<T>`\n\nget the union type of all the keys in an object type `T`<br>\nhttps://flow.org/en/docs/types/utilities/#toc-keys\n\n**Usage:**\n\n```ts\nimport { $Keys } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: \"name\" | \"age\" | \"visible\"\ntype PropsKeys = $Keys<Props>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$Values<T>`\n\nget the union type of all the values in an object type `T`<br>\nhttps://flow.org/en/docs/types/utilities/#toc-values\n\n**Usage:**\n\n```ts\nimport { $Values } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: string | number | boolean\ntype PropsValues = $Values<Props>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### <a id=\"readonly2\"></a> `$ReadOnly<T>`\n\nget the read-only version of a given object type `T`<br>\nhttps://flow.org/en/docs/types/utilities/#toc-readonly\n\n**Usage:**\n\n```ts\nimport { $ReadOnly } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: Readonly<{ name: string; age?: number | undefined; visible: boolean; }>\ntype ReadOnlyProps = $ReadOnly<Props>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### <a id=\"diff2\"></a> `$Diff<T, U>`\n\nget the set difference of a given object types `T` and `U` (`T \\ U`)<br>\nhttps://flow.org/en/docs/types/utilities/#toc-diff\n\n**Usage:**\n\n```ts\nimport { $Diff } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\ntype DefaultProps = { age: number };\n\n// Expect: { name: string; visible: boolean; }\ntype RequiredProps = $Diff<Props, DefaultProps>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$PropertyType<T, K>`\n\nget the type of property of an object at a given key `K`<br>\nhttps://flow.org/en/docs/types/utilities/#toc-propertytype\n\n**Usage:**\n\n```ts\nimport { $PropertyType } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n// Expect: string\ntype NameType = $PropertyType<Props, 'name'>;\n\ntype Tuple = [boolean, number];\n// Expect: boolean\ntype A = $PropertyType<Tuple, '0'>;\n// Expect: number\ntype B = $PropertyType<Tuple, '1'>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$ElementType<T, K>`\n\nget the type of elements inside of array, tuple or object of type `T`, that matches the given index type `K`<br>\nhttps://flow.org/en/docs/types/utilities/#toc-elementtype\n\n**Usage:**\n\n```ts\nimport { $ElementType } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n// Expect: string\ntype NameType = $ElementType<Props, 'name'>;\n\ntype Tuple = [boolean, number];\n// Expect: boolean\ntype A = $ElementType<Tuple, 0>;\n// Expect: number\ntype B = $ElementType<Tuple, 1>;\n\ntype Arr = boolean[];\n// Expect: boolean\ntype ItemsType = $ElementType<Arr, number>;\n\ntype Obj = { [key: string]: number };\n// Expect: number\ntype ValuesType = $ElementType<Obj, string>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$Call<T>`\n\nget the return type of a given expression type<br>\nhttps://flow.org/en/docs/types/utilities/#toc-call\n\n**Usage:**\n\n```ts\nimport { $Call } from 'utility-types';\n\n// Common use-case\nconst add = (amount: number) => ({ type: 'ADD' as 'ADD', payload: amount });\ntype AddAction = $Call<typeof returnOfIncrement>; // { type: 'ADD'; payload: number }\n\n// Examples migrated from Flow docs\ntype ExtractPropType<T extends { prop: any }> = (arg: T) => T['prop'];\ntype Obj = { prop: number };\ntype PropType = $Call<ExtractPropType<Obj>>; // number\n// type Nope = $Call<ExtractPropType<{ nope: number }>>; // Error: argument doesn't match `Obj`.\n\ntype ExtractReturnType<T extends () => any> = (arg: T) => ReturnType<T>;\ntype Fn = () => number;\ntype FnReturnType = $Call<ExtractReturnType<Fn>>; // number\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$Shape<T>`\n\nCopies the shape of the type supplied, but marks every field optional.<br>\nhttps://flow.org/en/docs/types/utilities/#toc-shape\n\n**Usage:**\n\n```ts\nimport { $Shape } from 'utility-types';\n\ntype Props = { name: string; age: number; visible: boolean };\n\n// Expect: Partial<Props>\ntype PartialProps = $Shape<Props>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `$NonMaybeType<T>`\n\nConverts a type `T` to a non-maybe type. In other words, the values of `$NonMaybeType<T>` are the values of `T` except for `null` and `undefined`.<br>\nhttps://flow.org/en/docs/types/utilities/#toc-nonmaybe\n\n**Usage:**\n\n```ts\nimport { $NonMaybeType } from 'utility-types';\n\ntype MaybeName = string | null;\n\n// Expect: string\ntype Name = $NonMaybeType<MaybeName>;\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### `Class<T>`\n\nGiven a type T representing instances of a class C, the type Class<T> is the type of the class C<br>\nhttps://flow.org/en/docs/types/utilities/#toc-class\n\\* Differs from original Flow's util - implements only constructor part and won't include any static members. Additionally classes in Typescript are not treated as nominal\n\n**Usage:**\n\n```ts\nimport { Class } from 'utility-types';\n\n\nfunction makeStore(storeClass: Class<Store>): Store {\n  return new storeClass();\n}\n```\n\n[⇧ back to top](#flows-utility-types)\n\n### mixed\n\nAn arbitrary type that could be anything (same as `unknown`)<br>\nhttps://flow.org/en/docs/types/mixed\n\n[⇧ back to top](#table-of-contents)\n\n---\n\n## Related Projects\n\n- [`ts-toolbelt`](https://github.com/pirix-gh/ts-toolbelt) - Higher type safety for TypeScript\n- [`$mol_type`](https://github.com/eigenmethod/mol/tree/master/type) - Collection of TypeScript meta types for complex logic\n\n---\n\n## License\n\n[MIT License](/LICENSE)\n\nCopyright (c) 2016 Piotr Witek <mailto:piotrek.witek@gmail.com> (http://piotrwitek.github.io)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2016 Piotr Witek <piotrek.witek@gmail.com> (http://piotrwitek.github.io)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/utility-types/-/utility-types-3.10.0.tgz#ea4148f9a741015f05ed74fd615e1d20e6bed82b",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/utility-types/-/utility-types-3.10.0.tgz",
    "hash": "ea4148f9a741015f05ed74fd615e1d20e6bed82b",
    "integrity": "sha512-O11mqxmi7wMKCo6HKFt5AhO4BwY3VV68YU07tgxfz8zJTIxr4BpsezN49Ffwy9j3ZpwwJp4fkRwjRzq3uWE6Rg==",
    "registry": "npm",
    "packageName": "utility-types",
    "cacheIntegrity": "sha512-O11mqxmi7wMKCo6HKFt5AhO4BwY3VV68YU07tgxfz8zJTIxr4BpsezN49Ffwy9j3ZpwwJp4fkRwjRzq3uWE6Rg== sha1-6kFI+adBAV8F7XT9YV4dIOa+2Cs="
  },
  "registry": "npm",
  "hash": "ea4148f9a741015f05ed74fd615e1d20e6bed82b"
}