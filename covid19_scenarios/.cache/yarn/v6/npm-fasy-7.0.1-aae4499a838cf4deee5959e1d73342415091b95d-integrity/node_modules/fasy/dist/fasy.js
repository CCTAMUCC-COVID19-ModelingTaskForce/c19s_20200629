/*! fasy.js
	v7.0.1 (c) 2019 Kyle Simpson
	MIT License: http://getify.mit-license.org
*/

!function UMD(e,r,n){"function"==typeof define&&define.amd?define(n):"undefined"!=typeof module&&module.exports?module.exports=n():r[e]=n(e,r)}("FA",this,function DEF(e,r){"use strict";var n={},t=new Promise(function c(){}),u={async reduce(e,r,n=[]){e=_runner(e);var t=r;for(let[r,u]of n.entries())t=await e(t,u,r,n);return t},async reduceRight(e,r,n=[]){e=_runner(e);var t=r;for(let[r,u]of[...n.entries()].reverse())t=await e(t,u,r,n);return t},pipe:(e=[])=>(0==e.length&&(e=[e=>e]),function piped(...r){return u.reduce(function reducer(e,n){return e===r?n(...e):n(e)},r,e)}),compose:(e=[])=>(0==e.length&&(e=[e=>e]),function composed(...r){return u.reduceRight(function reducer(e,n){return e===r?n(...e):n(e)},r,e)})},c={filter:e=>(function curried(r){return async function reducer(n,t,u,c){return await _runner(e)(t,u,c)?_runner(r)(n,t):n}}),map:e=>(function curried(r){return async function reducer(n,t,u,c){return _runner(r)(n,await _runner(e)(t,u,c))}}),async transduce(e,r,n,t=[]){var c=await e(r);return u.reduce(c,n,t)},async into(e,r,n=[]){var t="string"==typeof r?c.string:"number"==typeof r?c.number:"boolean"==typeof r?c.booleanAnd:Array.isArray(r)?c.array:c.default;return c.transduce(e,t,r,n)},string:(e,r)=>e+r,number:(e,r)=>e+r,booleanAnd:(e,r)=>e&&r,booleanOr:(e,r)=>e||r,array:(e,r)=>(e.push(r),e),default:(e,r)=>e};return Object.assign(defineConcurrentAPI,defineConcurrentAPI(Number.MAX_SAFE_INTEGER)),Object.assign(u,defineConcurrentAPI(1)),u.filter=u.filterIn,{concurrent:defineConcurrentAPI,serial:u,transducers:c};function defineConcurrentAPI(e=5,r=e){if(e=Number(e),r=Number(r),!(e>=1))throw new Error("Batch size limit must be at least 1.");if(!(r>=1&&r<=e))throw new Error(`Minimum active threshold must be between 1 and ${e}.`);var c=`${e}:${r}`;if(!(c in n)){let e=function concurrentMap(e,r){return async function map(e,n=[]){e=_runner(e);for(var u=n.entries(),c=0,i=[],o=[];;)if(c<r){let r=u.next();if(r.done)return Promise.all(i);{let[u,a]=r.value;c++,o[u]=i[u]=e(a,u,n).then(function mapped(e){return c--,o[u]=t,e})}}else await Promise.race(o)}}(0,r),i=function concurrentFilterIn(e){return async function filterIn(r,n=[]){return r=_runner(r),(await e(async function mapper(e,n,t){return[e,await r(e,n,t)]},n)).reduce(function reducer(e,[r,n]){return n?[...e,r]:e},[])}}(e);n[c]={forEach:concurrentForEach(e),map:e,flatMap:concurrentFlatMap(e),filter:i,filterIn:i,filterOut:concurrentFilterOut(i),reduce:u.reduce,reduceRight:u.reduceRight,pipe:u.pipe,compose:u.compose}}return n[c]}function concurrentForEach(e){return async function forEach(r,n=[]){await e(r,n)}}function concurrentFlatMap(e){return async function flatMap(r,n=[]){return(await e(r,n)).reduce(function reducer(e,r){return e.concat(r)},[])}}function concurrentFilterOut(e){return async function filterOut(r,n=[]){return r=_runner(r),e(async function filterer(e,n,t){return!await r(e,n,t)},n)}}function _runner(e){return async function getArgs(...r){var n=e(...r);return n&&"function"==typeof n.next&&"function"==typeof n[Symbol.iterator]?Promise.resolve().then(function handleNext(e){return function handleResult(e){return e.done?e.value:Promise.resolve(e.value).then(handleNext,function handleErr(e){return Promise.resolve(n.throw(e)).then(handleResult)})}(n.next(e))}):n}}});