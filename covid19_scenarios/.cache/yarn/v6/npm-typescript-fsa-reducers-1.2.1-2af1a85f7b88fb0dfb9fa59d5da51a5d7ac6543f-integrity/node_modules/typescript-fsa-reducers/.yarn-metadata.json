{
  "manifest": {
    "name": "typescript-fsa-reducers",
    "version": "1.2.1",
    "description": "Fluent syntax for defining typesafe Redux reducers on top of typescript-fsa.",
    "main": "dist/index.js",
    "types": "dist/index",
    "files": [
      "dist/"
    ],
    "repository": {
      "type": "git",
      "url": "git://github.com/dphilipson/typescript-fsa-reducers.git"
    },
    "keywords": [
      "redux",
      "typescript",
      "action",
      "reducer",
      "builder"
    ],
    "author": {
      "name": "David Philipson",
      "email": "david.philipson@gmail.com",
      "url": "http://dphil.me"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/dphilipson/typescript-fsa-reducers/issues"
    },
    "homepage": "https://github.com/dphilipson/typescript-fsa-reducers#readme",
    "scripts": {
      "build": "yarn run clean && tsc -p tsconfig.build.json",
      "clean": "rm -rf dist/*",
      "format-file": "prettier --write",
      "format": "git ls-files | egrep '\\.(js(on)?|scss|tsx?)?$' | xargs yarn run format-file",
      "generate-toc": "git ls-files | egrep '\\.md$' | xargs scripts/markdown-toc-all.sh",
      "jest": "jest",
      "lint-file": "tslint",
      "lint": "tslint --project .",
      "prepublishOnly": "yarn run test && yarn run build",
      "test": "yarn run lint && tsc && yarn run jest"
    },
    "husky": {
      "hooks": {
        "pre-commit": "lint-staged"
      }
    },
    "lint-staged": {
      "**/*.{js,json}": [
        "yarn run format-file",
        "git add"
      ],
      "**/*.ts": [
        "yarn run format-file",
        "yarn run lint-file --fix",
        "git add"
      ],
      "*.md": [
        "./scripts/markdown-toc-all.sh",
        "git add"
      ]
    },
    "devDependencies": {
      "@types/jest": "^23.3.3",
      "husky": "^1.1.1",
      "jest": "^23.6.0",
      "lint-staged": "^7.3.0",
      "markdown-toc": "^1.2.0",
      "prettier": "^1.14.3",
      "ts-jest": "^23.10.3",
      "tslint": "^5.11.0",
      "tslint-config-prettier": "^1.15.0",
      "typescript": "^3.1.1",
      "typescript-fsa": "^3.0.0-beta-2"
    },
    "peerDependencies": {
      "typescript-fsa": "*"
    },
    "_registry": "npm",
    "_loc": "/home/ekrell/Documents/Work/repos/COVID19/c19s_20200629/covid19_scenarios/.cache/yarn/v6/npm-typescript-fsa-reducers-1.2.1-2af1a85f7b88fb0dfb9fa59d5da51a5d7ac6543f-integrity/node_modules/typescript-fsa-reducers/package.json",
    "readmeFilename": "README.md",
    "readme": "# TypeScript FSA Reducers\n\nFluent syntax for defining typesafe Redux reducers on top of\n[typescript-fsa](https://github.com/aikoven/typescript-fsa).\n\n[![Build\nStatus](https://travis-ci.org/dphilipson/typescript-fsa-reducers.svg?branch=master)](https://travis-ci.org/dphilipson/typescript-fsa-reducers)\n\n## Introduction\n\nThis library will allow you to write typesafe reducers that look like this:\n\n```ts\nconst reducer = reducerWithInitialState(INITIAL_STATE)\n    .case(setName, setNameHandler)\n    .case(addBalance, addBalanceHandler)\n    .case(setIsFrozen, setIsFrozenHandler);\n```\n\nIt removes the boilerplate normally associated with writing reducers, including\nif-else chains, the default case, and the need to pull the payload field off of\nthe action.\n\n## Table of Contents\n\n<!-- toc -->\n\n- [Usage](#usage)\n- [Installation](#installation)\n- [API](#api)\n  * [Starting a reducer chain](#starting-a-reducer-chain)\n    + [`reducerWithInitialState(initialState)`](#reducerwithinitialstateinitialstate)\n    + [`reducerWithoutInitialState()`](#reducerwithoutinitialstate)\n    + [`upcastingReducer()`](#upcastingreducer)\n  * [Reducer chain methods](#reducer-chain-methods)\n    + [`.case(actionCreator, handler(state, payload) => newState)`](#caseactioncreator-handlerstate-payload--newstate)\n    + [`.caseWithAction(actionCreator, handler(state, action) => newState)`](#casewithactionactioncreator-handlerstate-action--newstate)\n    + [`.cases(actionCreators, handler(state, payload) => newState)`](#casesactioncreators-handlerstate-payload--newstate)\n    + [`.casesWithAction(actionCreators, handler(state, action) => newState)`](#caseswithactionactioncreators-handlerstate-action--newstate)\n    + [`.withHandling(updateBuilder(builder) => builder)`](#withhandlingupdatebuilderbuilder--builder)\n    + [`.default(handler(state, action) => newState)`](#defaulthandlerstate-action--newstate)\n    + [`.build()`](#build)\n\n<!-- tocstop -->\n\n## Usage\n\nThis library allows you to define reducers by chaining a series of handlers for\ndifferent action types and optionally providing an initial value. It builds on\ntop of and assumes familiarity with the excellent\n[typescript-fsa](https://github.com/aikoven/typescript-fsa).\n\nSuppose we have used [typescript-fsa](https://github.com/aikoven/typescript-fsa)\nto define our state and some actions:\n\n```ts\nimport actionCreatorFactory from \"typescript-fsa\";\nconst actionCreator = actionCreatorFactory();\n\ninterface State {\n    name: string;\n    balance: number;\n    isFrozen: boolean;\n}\n\nconst INITIAL_STATE: State = {\n    name: \"Untitled\",\n    balance: 0,\n    isFrozen: false,\n};\n\nconst setName = actionCreator<string>(\"SET_NAME\");\nconst addBalance = actionCreator<number>(\"ADD_BALANCE\");\nconst setIsFrozen = actionCreator<boolean>(\"SET_IS_FROZEN\");\n```\n\nUsing vanilla `typescript-fsa`, we might define a reducer as follows:\n\n```ts\nimport { Action } from \"redux\";\nimport { isType } from \"typescript-fsa\";\n\nfunction reducer(state = INITIAL_STATE, action: Action): State {\n    if (isType(action, setName)) {\n        return { ...state, name: action.payload };\n    } else if (isType(action, addBalance)) {\n        return {\n            ...state,\n            balance: state.balance + action.payload,\n        };\n    } else if (isType(action, setIsFrozen)) {\n        return { ...state, isFrozen: action.payload };\n    } else {\n        return state;\n    }\n}\n```\n\nUsing this library, the above is exactly equivalent to the following code:\n\n```ts\nimport { reducerWithInitialState } from \"typescript-fsa-reducers\";\n\nconst reducer = reducerWithInitialState(INITIAL_STATE)\n    .case(setName, (state, name) => ({ ...state, name }))\n    .case(addBalance, (state, amount) => ({\n        ...state,\n        balance: state.balance + amount,\n    }))\n    .case(setIsFrozen, (state, isFrozen) => ({ ...state, isFrozen }));\n```\n\nNote that unlike the vanilla case, there is no need to pull the payload off of\nthe action, as it is passed directly to the handler, nor is it necessary to\nspecify a default case which returns `state` unmodified.\n\nEverything is typesafe. If the types of the action payload and handler don't\nline up, then TypeScript will complain. If you find it easier to read, you can\nof course pull out the handlers into separate functions, as shown in the\n[Introduction](#introduction).\n\nIf the full action is needed rather than just the payload, `.caseWithAction()`\nmay be used in place of `.case()`. This may be useful if you intend to pass the\naction unchanged to a different reducer, or if you need to read the `meta` field\nof the action. For example:\n\n```ts\nimport { Action } from \"typescript-fsa\";\n\nconst setText = actionCreator<string>(\"SET_TEXT\");\n\nconst reducer = reducerWithInitialState({\n    text: \"\",\n    lastEditBy: \"\",\n}).caseWithAction(incrementCount, (state, { payload, meta }) => ({\n    text: payload,\n    lastEditBy: meta.author,\n}));\n\n// Returns { text: \"hello\", lastEditBy: \"cbrontë\" }.\nreducer(undefined, setText(\"hello\", { author: \"cbrontë\" }));\n```\n\nFurther, a single handler may be assigned to multiple action types at once using\n`.cases()` or `.casesWithAction()`:\n\n```ts\nconst reducer = reducerWithInitialState(initialState).cases(\n    [setName, addBalance],\n    (state, payload) => {\n        // Payload has type SetNamePayload | AddBalancePayload.\n        // ...\n    },\n);\n```\n\nThe reducer builder chains are mutable. Each call to `.case()` modifies the\ncallee to respond to the specified action type. If this is undesirable, see the\n[`.build()`](#build) method below.\n\n## Installation\n\nFor this library to be useful, you will also need\n[typescript-fsa](https://github.com/aikoven/typescript-fsa) to define your\nactions.\n\nWith Yarn:\n\n```\nyarn add typescript-fsa-reducers typescript-fsa\n```\n\nOr with NPM:\n\n```\nnpm install --save typescript-fsa-reducers typescript-fsa\n```\n\n## API\n\n### Starting a reducer chain\n\n#### `reducerWithInitialState(initialState)`\n\nStarts a reducer builder-chain which uses the provided initial state if passed\n`undefined` as its state. For example usage, see the [Usage](#usage) section\nabove.\n\n#### `reducerWithoutInitialState()`\n\nStarts a reducer builder-chain without special logic for an initial state.\n`undefined` will be treated like any other value for the state.\n\nRedux seems to really want you to provide an initial state for your reducers.\nIts `createStore` API encourages it and `combineReducers` function enforces it.\nFor the Redux author's reasoning behind this, see [this\nthread](https://github.com/reactjs/redux/issues/514). For this reason,\n`reducerWithInitialState` will likely be the more common choice, but the option\nto not provide an initial state is there in case you have some means of\ncomposing reducers for which initial state is unnecessary.\n\nNote that since the type of the state cannot be inferred from the initial state,\nit must be provided as a type parameter:\n\n```javascript\nconst reducer = reducerWithoutInitialState<State>()\n    .case(setName, setNameHandler)\n    .case(addBalance, addBalanceHandler)\n    .case(setIsFrozen, setIsFrozenHandler);\n```\n\n#### `upcastingReducer()`\n\nStarts a builder-chain which produces a \"reducer\" whose return type is a\nsupertype of the input state. This is most useful for handling a state which may\nbe in one of several \"modes\", each of which responds differently to actions and\ncan transition to the other modes. Many applications will not have a use for\nthis.\n\nNote that the function produced is technically not a reducer because the initial\nand updated states are different types.\n\nExample usage:\n\n```javascript\ntype State = StoppedState | RunningState;\n\ninterface StoppedState {\n    type: \"STOPPED\";\n}\n\ninterface StartedState {\n    type: \"STARTED\";\n    count: number;\n}\n\nconst INITIAL_STATE: State = { type: \"STOPPED\" };\n\nconst startWithCount = actionCreator<number>(\"START_WITH_COUNT\");\nconst addToCount = actionCreator<number>(\"ADD_TO_COUNT\");\nconst stop = actionCreator<void>(\"STOP\");\n\nfunction startWithCountHandler(state: StoppedState, count: number): State {\n    return { type: \"STARTED\", count };\n}\n\nfunction addToCountHandler(state: StartedState, count: number): State {\n    return { ...state, count: state.count + count };\n}\n\nfunction stopHandler(state: StartedState): State {\n    return { type: \"STOPPED\" };\n}\n\nconst stoppedReducer = upcastingReducer<StoppedState, State>()\n    .case(startWithCount, startWithCountHandler);\n\nconst startedReducer = upcastingReducer<StartedState, State>()\n    .case(addToCount, addToCountHandler)\n    .case(stop, stopHandler);\n\nfunction reducer(state = INITIAL_STATE, action: Redux.Action): State {\n    if (state.type === \"STOPPED\") {\n        return stoppedReducer(state, action);\n    } else if (state.type === \"STARTED\") {\n        return startedReducer(state, action);\n    } else {\n        throw new Error(\"Unknown state\");\n    }\n}\n```\n\n### Reducer chain methods\n\n#### `.case(actionCreator, handler(state, payload) => newState)`\n\nMutates the reducer such that it applies `handler` when passed actions matching\nthe type of `actionCreator`. For examples, see [Usage](#usage).\n\n#### `.caseWithAction(actionCreator, handler(state, action) => newState)`\n\nLike `.case()`, except that `handler` receives the entire action as its second\nargument rather than just the payload. This is useful if you want to read other\nproperties of the action, such as `meta` or `error`, or if you want to pass the\nentire action unmodified to some other function. For an example, see\n[Usage](#usage).\n\n#### `.cases(actionCreators, handler(state, payload) => newState)`\n\nLike `.case()`, except that multiple action creators may be provided and the\nsame handler is applied to all of them. That is,\n\n```javascript\nreducerWithInitialState(initialState).cases(\n    [setName, addBalance, setIsFrozen],\n    handler,\n);\n```\n\nis equivalent to\n\n```javascript\nreducerWithInitialState(initialState)\n    .case(setName, handler)\n    .case(addBalance, handler)\n    .case(setIsFrozen, handler);\n```\n\nNote that the payload passed to the handler may be of the type of any of the\nlisted action types' payloads. In TypeScript terms, this means it has type `P1 | P2 | ...`, where `P1, P2, ...` are the payload types of the listed action\ncreators.\n\nThe payload type is inferred automatically for up to four action types. After\nthat, it must be supplied as a type annotation, for example:\n\n```javascript\nreducerWithInitialState(initialState).cases <\n    { documentId: number } >\n    ([\n        selectDocument,\n        editDocument,\n        deleteDocument,\n        sendDocument,\n        archiveDocument,\n    ],\n    handler);\n```\n\n#### `.casesWithAction(actionCreators, handler(state, action) => newState)`\n\nLike `.cases()`, except that the handler receives the entire action as its\nsecond argument rather than just the payload.\n\n#### `.withHandling(updateBuilder(builder) => builder)`\n\nConvenience method which applies the provided function to the current builder\nand returns the result. Useful if you have a sequence of builder updates (calls\nto `.case()`, etc.) which you want to reuse across several reducers.\n\n#### `.default(handler(state, action) => newState)`\n\nProduces a reducer which applies `handler` when no previously added `.case()`,\n`.caseWithAction()`, etc. matched. The handler is similar to the one in\n`.caseWithAction()`. Note that `.default()` ends the chain and internally does\nthe same as [`.build()`](#build), because it is not intended that the chain be\nmutated after calling `.default()`.\n\nThis is useful if you have a \"delegate\" reducer that should be called on any\naction after handling a few specific actions in the parent.\n\n```ts\nconst NESTED_STATE = {\n    someProp: \"hello\",\n};\n\nconst nestedReducer = reducerWithInitialState(NESTED_STATE)\n    .case(...);\n\nconst INITIAL_STATE = {\n    someOtherProp: \"world\"\n    nested: NESTED_STATE\n};\n\nconst reducer = reducerWithInitialState(INITIAL_STATE)\n    .case(...)\n    .default((state, action) => ({\n        ...state,\n        nested: nestedReducer(state.nested, action),\n    }));\n```\n\n#### `.build()`\n\nReturns a plain reducer function whose behavior matches the current state of the\nreducer chain. Further updates to the chain (through calls to `.case()`) will\nhave no effect on this function.\n\nThere are two reasons you may want to do this:\n\n1.  **You want to ensure that the reducer is not modified further**\n\n    Calling `.build()` is an example of defensive coding. It prevents someone\n    from causing confusing behavior by importing your reducer in an unrelated\n    file and adding cases to it.\n\n2.  **You want your package to export a reducer, but not have its types depend\n    on `typescript-fsa-reducers`**\n\n    If the code that defines a reducer and the code that uses it reside in\n    separate NPM packages, you may run into type errors since the exported\n    reducer has type `ReducerBuilder`, which the consuming package does not\n    recognize unless it also depends on `typescript-fsa-reducers`. This is\n    avoided by returning a plain function instead.\n\nExample usage:\n\n```javascript\nconst reducer = reducerWithInitialState(INITIAL_STATE)\n    .case(setName, setNameHandler)\n    .case(addBalance, addBalanceHandler)\n    .case(setIsFrozen, setIsFrozenHandler)\n    .build();\n```\n\nCopyright © 2017 David Philipson\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 David Philipson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/typescript-fsa-reducers/-/typescript-fsa-reducers-1.2.1.tgz#2af1a85f7b88fb0dfb9fa59d5da51a5d7ac6543f",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/typescript-fsa-reducers/-/typescript-fsa-reducers-1.2.1.tgz",
    "hash": "2af1a85f7b88fb0dfb9fa59d5da51a5d7ac6543f",
    "integrity": "sha512-Qgn7zEnAU5n3YEWEL5ooEmIWZl9B4QyXD4Y/0DqpUzF0YuTrcsLa7Lht0gFXZ+xqLJXQwo3fEiTfQTDF1fBnMg==",
    "registry": "npm",
    "packageName": "typescript-fsa-reducers",
    "cacheIntegrity": "sha512-Qgn7zEnAU5n3YEWEL5ooEmIWZl9B4QyXD4Y/0DqpUzF0YuTrcsLa7Lht0gFXZ+xqLJXQwo3fEiTfQTDF1fBnMg== sha1-KvGoX3uI+w37n6WdXaUaXXrGVD8="
  },
  "registry": "npm",
  "hash": "2af1a85f7b88fb0dfb9fa59d5da51a5d7ac6543f"
}